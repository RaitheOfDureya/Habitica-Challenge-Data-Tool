<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Challenge Data Tool</title>
    <base target="_blank">

<!--

This code is licensed under the same terms as Habitica:
    https://raw.githubusercontent.com/HabitRPG/habitrpg/develop/LICENSE
    https://raw.githubusercontent.com/HabitRPG/habitrpg/develop/LICENSE

https://github.com/cTheDragons/Habitica-Challenge-Data-Tool

https://oldgods.net/habitica/cTheDragons/challenge.html
   

Contributors:
    cTheDragons https://github.com/cTheDragons
	based on code from
	Alys (Alice Harris), lady_alys@oldgods.net https://github.com/Alys
    thepeopleseason (James Hsiao) https://github.com/thepeopleseason
    goldfndr (Richard Finegold) https://github.com/goldfndr
    Blade Barringer https://github.com/crookedneighbor
    donoftime https://github.com/donoftime
    me_and (Adam Dinwoodie) https://github.com/me-and
	

-->


    <meta name="description" content="Challenge Data Tool" />
    <meta name="author" content="cTheDragons" />

	
	

	<script src="https://code.jquery.com/jquery-1.12.3.js"></script> <!--- jquery -->
	<script src="https://momentjs.com/downloads/moment-with-locales.min.js"></script> <!--- time functions -->
	<script src="js/habitica-markdown.min.js"></script> <!--- Markdown -->
	<script src="js/habitica-avatar.js"></script>  <!--- Avatar Generation https://github.com/crookedneighbor/habitica-avatar -->
	<script src="js/lodash.js"></script> <!--lodash / copy objects -->
	

	 <!--- https://datatables.net/download/ -->
	<script type="text/javascript" src="https://cdn.datatables.net/v/dt/jszip-2.5.0/pdfmake-0.1.18/dt-1.10.12/b-1.2.2/b-colvis-1.2.2/b-flash-1.2.2/b-html5-1.2.2/b-print-1.2.2/se-1.2.0/datatables.min.js"></script>
	<link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/v/dt/jszip-2.5.0/pdfmake-0.1.18/dt-1.10.12/b-1.2.2/b-colvis-1.2.2/b-flash-1.2.2/b-html5-1.2.2/b-print-1.2.2/se-1.2.0/datatables.min.css"/>
 	
<script type="text/javascript">
$(function() { // wraps around all our code to not pollute global namespace

//////////////////////////////////////////////////////////////////////
////   Global Variables                              /////////////////
//////////////////////////////////////////////////////////////////////

var content;  	// holds site-wide content (gear names and stats, quests, etc)
var user;    	 // holds user's data
var challenge;	// holds all challenge data
var challengeTasks;	// holds all challenge data
var challengeForUser; //Holds all the challenges the user has access to.
var group;	// holds all challenge data
var memberListToFetch = []; //holds memberList that is fetching (30 limit)  
var memberListToFetch_idOnly = []; //holds memberList that is fetching (30 limit) 
var members;  // hold members of challenge participants 
var membersChallenge;  // hold members of challenge tasks 
var membersTask; //holds information per task per member
var membersTaskHistory; //holds information per completion per task per member
var lastListMemberId = '';  // hold last member id to be used with groups 
var memberIdSelection; //holds membersIdSelection
var userIsAdmin; //holds if the user is an Admin or not
var newFetch; //holds if first fetch (therefore tables to be built and random member etc) is requried.

//////////////////////////////////////////////////////////////////////
////   Global Constants                              /////////////////
//////////////////////////////////////////////////////////////////////
var DOUBLEQUOTES = 		'"' //This is to make my life easier... 
var SECTIONREFRESH = 	"SectionRefresh"
var TABLEDISPLAYSUFFIX = '_display'

var altChatGuild =		{
							'00000000-0000-4000-A000-000000000000': {name: 'Tavern', nameAlt: 'Tavern Overflow', alt:'e8e2f1ce-ae18-4cb1-8dd8-8e4adc59442f'},
							'5481ccf3-5d2d-48a9-a871-70a7380cee5a': {name: 'Habitica Help', nameAlt: 'Tavern Overflow', alt:'e8e2f1ce-ae18-4cb1-8dd8-8e4adc59442f'},	
							'8c492c97-2fcc-40b4-b574-89543a719634': {name: 'The Duelling Grounds', nameAlt: 'The Duelling Grounds Tally Board', alt:'87e8ace7-614f-4537-b187-7536d14ae70f'}
						}	
//////////////////////////////////////////////////////////////////////
////   Sections                              /////////////////
//////////////////////////////////////////////////////////////////////

		// TO ADD NEW SECTION: To create a Table of Content entry and Main,
		// add the unique identifier for the new section to array section to Display. 
		// If it is a section that displays table content update sectionTables too. 
		// If new content is required see formatAllDataAndCollate() 
		
		//If custom sections required add to below the Sections data... (Not there yet)


//index array for looping
var dashboardToDisplay = [
	{id: 'memberTotal', label: 'Total Participants', hoverText: 'Total Participants in the Challenge', value: 'challenge.memberTotals.fetchCount', status: 'neutral', showOnly: []},
	{id: 'memberInInn', label: 'In Inn', hoverText: 'Total Participants In the Inn', value: 'challenge.memberTotals.inInn', status: 'danger', showOnly: []},
	{id: 'taskPositive', label: 'Positive Clicks', hoverText: 'Total Positive Task Clicks/Completion', value: 'challenge.challengeStats.countPositive', status: 'safe', showOnly: []},
	{id: 'taskNegative', label: 'Negative Clicks', hoverText: 'Total Positive Task Clicks/Completion', value: 'challenge.challengeStats.countNegative', status: 'danger', showOnly: []}
]


var sectionsToDisplay = [	
	{type: 'heading', id: 'headingGroup', title: 'Challenge Details', showOnly: [], description: ''},
		{type: 'sectionCustom', id: 'overview', title: 'Overview', showOnly: [], description: 'Overview of Challenge with some challenge Stats.', functionCreate: 'formatOverviewSection'},
		{type: 'sectionTable', id: 'memberList', title: 'Participant List', showOnly: [], description: 'A table listing profile information of each participant of the group.'},
		{type: 'sectionTable', id: 'memberActivity', title: 'Participant Activity', showOnly: [], description: 'A table listing how active each participant of the group is (date-hour format).'},
		{type: 'sectionCustom', id: 'perMemberStats', title: 'Per Participant Stats/Random Winner', showOnly: [], description: 'Allows the picking of a Random Winner and individually seeing each participant stats', functionCreate: 'formatPerMemberStatsSection'},
	{type: 'heading', id: 'headingMember', title: 'Completion Stats', showOnly: [], description: ''},
		{type: 'sectionTable', id: 'taskChallenge', title: 'Tasks Overall', showOnly: [], description: 'A table listing the summary  completion statics for each task of the challenge. Great for comparing Guild Versus Guild.'},
		{type: 'sectionTable', id: 'membersChallenge', title: 'Participant Overall', showOnly: [], description: 'A table listing the summary  completion statics for each participant of the challenge.'},
		{type: 'sectionTable', id: 'membersTask', title: 'Participant per Task', showOnly: [], description: 'A table listing the summary completion statics for each participant for each task of the challenge.'},
		{type: 'sectionTable', id: 'membersTaskHistory', title: 'All Task History', showOnly: [], description: 'A table listing the each time a task was completed for all tasks for all participants.'},
	{type: 'heading', id: 'headingGroup2', title: 'Communication', showOnly: [], description: ''},
		{type: 'sectionTable', id: 'chatExport', title: 'Chat Export', showOnly: [], description: 'Displays the chat in which the challenge was posted, or the guild where chat messages should show, ie for Tavern, the chat from Tavern Challenge OverFlow Shows'},
		{type: 'sectionTable', id: 'chatNotSystemExport', title: 'Chat Export without System Msg', showOnly: ['party'], description: 'Will only show if party is selected. Displays the chat in which the challenge was posted, or the guild where chat messages should show.'},
		{type: 'sectionTable', id: 'chatSystemExport', title: 'Chat Export only System Msg', showOnly: ['party'], description: 'Will only show if party is selected. Displays the chat in which the challenge was posted, or the guild where chat messages should show.'},
		{type: 'sectionTable', id: 'chatLikes', title: 'Chat Likes', showOnly: [], description: 'Shows who has liked which chat message.'},
		{type: 'sectionTable', id: 'displayInboxSection', title: 'PMs', showOnly: [], description: 'Displays personal messages you have exchanged with participants of this challenge.'}
]

var sectionTables =	{}
sectionTables['memberList'] = {
	type: 'member',
	dataSet: [], 
	dataSetHeader: ['User Id', 'Username', 'Display Name', 'Profile', 'Class', 'Level', 'Tier', 'Contributor', 'Contributions',  'Mod',  'Born', 'Next Birthday', 'Can PM?', 'Avatar'],
	dataTable: ['id', 'profile.usernameNotPretty', 'profile.nameNotPretty', 'blurbPretty', 'stats.classPretty', 'stats.lvl', 'contribPretty.level', 'contribPretty.text',  'contribPretty.contributions', 'contribPretty.admin',  'creation.shortDate',  'creation.nextBirthday.shortDate', 'inbox.canPM', 'profile.avatar'],
	babyBear: {show: [1,4,5,13], orderBy: [[1, 'asc']]},
	mamaBear: {show: [0,1,3,4,5,6,7,11,13], orderBy: [[1, 'asc']]},
	papaBear: {show: ['all'], orderBy: [[1, 'asc']]},
	extraColumnDefs: [{'className': 'dt-center', 'targets': [9,12]}, {'className': 'dt-right', 'targets': [5,6,10,11]}],
	subTitle: function (){
		var html = ''
		html += sectionHeadingLeadership()
		return html 
	},	
	leadershipButton: true,
	uuidIndex: 0,
	nameIndex: 1
}
sectionTables['memberActivity'] = {
	type: 'member',
	dataSet: [], 
	dataSetHeader: ['User Id', 'Username', 'Display Name', 'Class', 'Level', 'Tier', 'Born', 'Last Active', 'Last In Challenge', 'Last Cron', 'Last Drop', 'Last Chat', 'Total Chat Lines', 'Last Chat Text', 'In Inn'], 
	dataTable: ['id', 'profile.usernameNotPretty', 'profile.nameNotPretty', 'stats.classPretty', 'stats.lvl',  'contribPretty.level', 'creation.shortDate', 'lastActive.shortDate', 'challengeStats.last.shortDate', 'lastLoggedIn.shortDate', 'lastDropItem.shortDate', 'lastChat.occured.shortDate', 'lastChat.countTotal', 'lastChat.textPretty', 'preferences.sleep'],
	babyBear: {show: [1,7,8,13], orderBy: [[1, 'asc']]},
	mamaBear: {show: [0,1,3,6,7,8,9,10,11,13], orderBy: [[1, 'asc']]},
	papaBear: {show: ['all'], orderBy: [[1, 'asc']]},
	extraColumnDefs: [{'className': 'dt-center', 'targets': [14]}, {'className': 'dt-right', 'targets': [4,5,6,7,8,9,10,11,12]}],
	subTitle: function (){
		var html = sectionHeadingLastActive()
		html += sectionHeadingLeadership()
		return html 
	},
	leadershipButton: true,
	uuidIndex: 0,
	nameIndex: 1
}


sectionTables['taskChallenge'] = {
	type: 'challengeTask',
	dataSet: [], 
	dataSetHeader: ['Task Id', 'Task Type', 'Task Name', 'Task Notes', 'Created',  'Last Updated', 'First Completion',  'Latest Completion',  'Streak Min', 'Streak Max', 'Streak Neg Min', 'Streak Neg Max', 'Total Clicks', 'Positive Clicks', 'Negative Clicks', 'Total Not Due', 'Time Diff Min', 'Time Diff Max','Time Diff Min ToDo', 'Time Diff Max ToDo', 'Time Diff Min Habit', 'Time Diff Max Habit', 'Time Diff Min Daily', 'Time Diff Max Daily', 'Value Diff Min', 'Value Diff Max' ], 
	dataTable: ['id', 'type', 'textNotPretty', 'notesPretty', 'creation.shortDate', 'lastUpdated.shortDate', 'challengeStats.first.shortDate',  'challengeStats.last.shortDate',  'challengeStats.streak.min', 'challengeStats.streak.max', 'challengeStats.streakNeg.min', 'challengeStats.streakNeg.max', 'challengeStats.count', 'challengeStats.countPositive', 'challengeStats.countNegative', 'challengeStats.countNotDue', 'challengeStats.timeDiffMin.overall', 'challengeStats.timeDiffMax.overall', 'challengeStats.timeDiffMin.todo', 'challengeStats.timeDiffMax.todo', 'challengeStats.timeDiffMin.habit', 'challengeStats.timeDiffMax.habit', 'challengeStats.timeDiffMin.daily',  'challengeStats.timeDiffMax.daily', 'challengeStats.valueDiffMin.overall', 'challengeStats.valueDiffMax.overall' ],
	babyBear: {show: [1,2,4,7,13,14], orderBy: [[1, 'asc']]},
	mamaBear: {show: [1,2,4,6,7,8,9,13,14,15,16,17], orderBy: [[1, 'asc']]},
	papaBear: {show: ['all'], orderBy: [[1, 'asc']]},
	extraColumnDefs: [{'className': 'dt-right', 'targets': [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]}],
	subTitle: function (){
		var html = ''
		html += sectionCompletionStats()
		html += ' '
		html += 'Reward History is currently not captured by Habitica.'
		return html 
	},	
	leadershipButton: false
}
sectionTables['membersChallenge'] = {
	type: 'member',
	dataSet: [], 
	dataSetHeader: ['User Id', 'Username', 'Display Name', 'Joined', 'Last Cron', 'Last Active',  'First Completion',  'Latest Completion',  'Streak Min', 'Streak Max', 'Streak Neg Min', 'Streak Neg Max', 'Total Clicks', 'Positive Clicks', 'Negative Clicks', 'Total Not Due', 'Time Diff Min', 'Time Diff Max', 'Time Diff Min Todo', 'Time Diff Max Todo', 'Time Diff Habit', 'Time Diff Max Habit', 'Time Diff Min Daily', 'Time Diff Max Daily', 'Value Diff Min', 'Value Diff Max', 'Value Diff Min Todo', 'Value Diff Max Todo', 'Value Diff Habit', 'Value Diff Max Habit', 'Value Diff Min Daily', 'Value Diff Max Daily'], 
	dataTable: ['id', 'profile.usernameNotPretty', 'profile.nameNotPretty', 'challengeStats.joined.shortDate',  'lastLoggedIn.shortDate', 'lastActive.shortDate', 'challengeStats.first.shortDate',  'challengeStats.last.shortDate',  'challengeStats.streak.min', 'challengeStats.streak.max', 'challengeStats.streakNeg.min', 'challengeStats.streakNeg.max', 'challengeStats.count', 'challengeStats.countPositive', 'challengeStats.countNegative', 'challengeStats.countNotDue', 'challengeStats.timeDiffMin.overall', 'challengeStats.timeDiffMax.overall', 'challengeStats.timeDiffMin.todo', 'challengeStats.timeDiffMax.todo', 'challengeStats.timeDiffMin.habit', 'challengeStats.timeDiffMax.habit', 'challengeStats.timeDiffMin.daily',  'challengeStats.timeDiffMax.daily', 'challengeStats.valueDiffMin.overall', 'challengeStats.valueDiffMax.overall', 'challengeStats.valueDiffMin.todo', 'challengeStats.valueDiffMax.todo', 'challengeStats.valueDiffMin.habit', 'challengeStats.valueDiffMax.habit', 'challengeStats.valueDiffMin.daily',  'challengeStats.valueDiffMax.daily'],
	babyBear: {show: [1,3,7,13,14], orderBy: [[1, 'asc']]},
	mamaBear: {show: [1,2,3,4,5,6,7,8,9,12,13,14,15,16,17], orderBy: [[1, 'asc']]},
	papaBear: {show: ['all'], orderBy: [[1, 'asc']]},
	extraColumnDefs: [{'className': 'dt-right', 'targets': [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]}],
	subTitle: function (){
		var html = ''
		html += sectionCompletionStats()
		html += sectionHeadingLeadership()
		return html 
	},
	reproduce: ['perMemberStats'],	
	reproduceSel: {perMemberStats: {selection:[0], hide:[0,1]}},	
	leadershipButton: true,
	uuidIndex: 0,
	nameIndex: 1
}
sectionTables['membersTask'] = {
	type: 'membersTask',
	dataSet: [], 
	dataSetHeader: ['User Id', 'Username', 'Display Name', 'Last Cron', 'UserTask Id', 'Task Id', 'Task Type', 'Task Name', 'Check List', 'Task Notes', 'Created',  'First Completion',  'Latest Completion',  'Reported Streak', 'Actual Current Streak', 'Streak Min', 'Streak Max', 'Streak Neg Min', 'Streak Neg Max', 'Total Clicks', 'Positive Clicks', 'Negative Clicks', 'Total Not Due', 'Time Diff Min', 'Time Diff Max', 'Value Diff Min', 'Value Diff Max'], 
	dataTable: ['member.id',  'member.profile.usernameNotPretty','member.profile.nameNotPretty',   'member.lastLoggedIn.shortDate', 'task.challenge.id', 'task.challenge.taskId', 'task.type', 'task.textNotPretty', 'task.checklistComp.fullListNotPretty', 'task.notesPretty',  'task.creation.shortDate',  'task.challengeStats.first.shortDate',  'task.challengeStats.last.shortDate',  'task.streak', 'task.challengeStats.streak.current', 'task.challengeStats.streak.min', 'task.challengeStats.streak.max', 'task.challengeStats.streakNeg.min', 'task.challengeStats.streakNeg.max', 'task.challengeStats.count', 'task.challengeStats.countPositive', 'task.challengeStats.countNegative', 'task.challengeStats.countNotDue', 'task.challengeStats.timeDiffMin', 'task.challengeStats.timeDiffMax', 'task.challengeStats.valueDiffMin', 'task.challengeStats.valueDiffMax'],
	babyBear: {show: [1,6,7,12,13,14,20,21], orderBy: [[1, 'asc'],[6, 'asc'],[7, 'asc']]},
	mamaBear: {show: [1,2,6,7,12,13,14,19,20,21,22,23,24], orderBy: [[1, 'asc'],[6, 'asc'],[7, 'asc']]},
	papaBear: {show: ['all'], orderBy: [[1, 'asc'],[6, 'asc'],[7, 'asc']]},
	extraColumnDefs: [{'className': 'dt-right', 'targets': [3,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]}],
	subTitle: function (){
		var html = ''
		html += sectionCompletionStats()
		html += sectionHeadingLeadership()
		return html 
	},
	reproduce: ['perMemberStats'],	
	reproduceSel: {perMemberStats: {selection:[0], hide:[0,1]}},	
	leadershipButton: true,
	uuidIndex: 0,
	nameIndex: 1
}
sectionTables['membersTaskHistory'] = {
	type: 'membersTaskHistory',
	dataSet: [], 
	dataSetHeader: ['User Id', 'Username', 'Display Name', 'Last Cron', 'UserTask Id', 'Task Id', 'Task Type', 'Task Name', 'Check List', 'Task Notes', 'Created',  'Clicked',  'Time Diff (Hrs)',  'Value', 'Value Diff', 'Postive Click', 'Negative Click'], 
	dataTable: ['member.id', 'member.profile.usernameNotPretty', 'member.profile.nameNotPretty',   'member.lastLoggedIn.shortDate', 'task.challenge.id', 'task.challenge.taskId', 'task.type', 'task.textNotPretty', 'task.checklistComp.fullListNotPretty', 'task.notesPretty', 'task.creation.shortDate', 'taskHistory.datePretty.shortDate', 'taskHistory.hourDiff', 'taskHistory.valuePretty', 'taskHistory.valueDiff', 'taskHistory.clickup', 'taskHistory.clickdown'],
	babyBear: {show: [1,6,7,11,12,15,16], orderBy: [[11, 'desc'],[1, 'asc'],[6, 'asc'],[7, 'asc'],[10, 'asc']]},
	mamaBear: {show: [1,2,3,6,7,8,9,10,11,12,13,15,16], orderBy: [[11, 'desc'],[1, 'asc'],[6, 'asc'],[7, 'asc'],[10, 'asc']]},
	papaBear: {show: ['all'], orderBy: [[11, 'desc'],[1, 'asc'],[6, 'asc'],[7, 'asc'],[10, 'asc']]},
	extraColumnDefs: [{'className': 'dt-right', 'targets': [3,10,11,12,13,14,15,16]}],
	subTitle: function (){
		var html = ''
		html += sectionCompletionStats()
		html += 'Habits clicks are summaries per day stats. The click date/time clicked is the last time it was clicked for that day.'
		html += sectionHeadingLeadership()
		return html 
	},
	reproduce: ['perMemberStats'],	
	reproduceSel: {perMemberStats: {selection:[0], hide:[0,1]}},	
	leadershipButton: true,
	uuidIndex: 0,
	nameIndex: 1
}
sectionTables['chatExport'] = {
	type: 'chat',
	dataSet: [], 
	dataSetHeader: ['Message Id', 'User Id', 'Username', 'Display Name', 'Tier', 'Contributor', 'Contributions', 'Mod', 'Posted', 'Epoch', 'Likes', 'Member Likes', 'Text', 'Appearance'], 
	dataTable: ['id', 'uuid', 'usernameNotPretty', 'userNotPretty', 'contribPretty.level', 'contribPretty.text', 'contribPretty.contributions', 'contribPretty.admin', 'creation.shortDate', 'timestamp', 'likeCount.total', 'likeCount.totalInGroup', 'textPretty', 'userStylesPretty'],
	babyBear: {show: [2,8,10,12], orderBy: [[8, 'desc']]},
	mamaBear: {show: [2,3,4,5,8,10,11,12], orderBy: [[8, 'desc']]},
	papaBear: {show: ['all'], orderBy: [[8, 'desc']]},
	extraColumnDefs: [{'className': 'dt-center', 'targets': [7]}, {'className': 'dt-right', 'targets': [4,9,10,11]}],
	subTitle: function (){
		var html = ''
	
		html += sectionHeadingChat()
		html += sectionHeadingLeadership()
		return html 
	},
	reproduce: ['perMemberStats'],	
	reproduceSel: {perMemberStats: {selection:[1], hide:[1,2,3,4,5,6]}},	
	leadershipButton: true,
	uuidIndex: 1,
	nameIndex: 2
}

sectionTables['chatNotSystemExport'] = {
	type: 'chat',
	dataSet: [], 
	dataSetHeader: ['Message Id', 'User Id', 'Username', 'Display Name', 'Tier', 'Contributor', 'Contributions', 'Mod', 'Posted', 'Epoch', 'Likes', 'Member Likes', 'Text', 'Appearance'], 
	dataTable: ['id', 'uuid', 'usernameNotPretty', 'userNotPretty', 'contribPretty.level', 'contribPretty.text', 'contribPretty.contributions', 'contribPretty.admin', 'creation.shortDate', 'timestamp', 'likeCount.total', 'likeCount.totalInGroup', 'textPretty', 'userStylesPretty'],
	babyBear: {show: [2,8,10,12], orderBy: [[8, 'desc']]},
	mamaBear: {show: [2,3,4,5,8,10,11,12], orderBy: [[8, 'desc']]},
	papaBear: {show: ['all'], orderBy: [[8, 'desc']]},
	extraColumnDefs: [{'className': 'dt-center', 'targets': [7]}, {'className': 'dt-right', 'targets': [4,9,10,11]}],
	subTitle: function (){
		var html = ''
		
		html += sectionHeadingChat()
		html += sectionHeadingLeadership()
		return html 
	},
	reproduce: ['perMemberStats'],	
	reproduceSel: {perMemberStats: {selection:[1], hide:[1,2,3,4,5,6]}},	
	leadershipButton: true,
	uuidIndex: 1,
	nameIndex: 2	
}

sectionTables['chatSystemExport'] = {
	type: 'chat',
	dataSet: [], 
	dataSetHeader: ['Message Id', 'User Id', 'Username', 'Display Name', 'Tier', 'Contributor', 'Contributions', 'Mod', 'Posted', 'Epoch', 'Likes', 'Member Likes', 'Text', 'Appearance'], 
	dataTable: ['id', 'uuid', 'usernameNotPretty', 'userNotPretty', 'contribPretty.level', 'contribPretty.text', 'contribPretty.contributions', 'contribPretty.admin', 'creation.shortDate', 'timestamp', 'likeCount.total', 'likeCount.totalInGroup', 'textPretty', 'userStylesPretty'],
	babyBear: {show: [2,8,10,12], orderBy: [[8, 'desc']]},
	mamaBear: {show: [2,3,4,5,8,10,11,12], orderBy: [[8, 'desc']]},
	papaBear: {show: ['all'], orderBy: [[8, 'desc']]},
	extraColumnDefs: [{'className': 'dt-center', 'targets': [7]}, {'className': 'dt-right', 'targets': [4,9,10,11]}],
	subTitle: function (){
		var html = ''
		
		html += sectionHeadingChat()
		return html 
	}
}

sectionTables['chatLikes'] = {
	type: 'chatLikes',
	dataSet: [], 
	dataSetHeader: ['Message Id', 'Like Id', 'Like UserName', 'Like Display Name', 'User Id', 'Username', 'Display Name', 'Tier', 'Contributor', 'Contributions', 'Mod', 'Posted', 'Epoch', 'Text'], 
	dataTable: ['chat.id', 'id', 'usernameNotPretty', 'nameNotPretty', 'chat.uuid', 'chat.usernameNotPretty', 'chat.userNotPretty', 'chat.contribPretty.level', 'chat.contribPretty.text', 'chat.contribPretty.contributions', 'chat.contribPretty.admin', 'chat.creation.shortDate', 'chat.timestamp', 'chat.textPretty'],
	babyBear: {show: [2,5,11,13], orderBy: [[11, 'desc']]},
	mamaBear: {show: [1,2,3,4,5,6,11,13], orderBy: [[11, 'desc']]},
	papaBear: {show: ['all'], orderBy: [[11, 'desc']]},
	extraColumnDefs: [{'className': 'dt-center', 'targets': [10]}, {'className': 'dt-right', 'targets': [7,12]}],
	subTitle: function (){
		var html = ''
		
		html += sectionHeadingChat()
		html += sectionHeadingLeadership()
		return html 
	},
	reproduce: ['perMemberStats'],	
	reproduceSel: {perMemberStats: {selection:[1], hide:[1,2]}},	
	leadershipButton: true,
	uuidIndex: 1,
	nameIndex: 2
}

sectionTables['displayInboxSection'] = {
	type: 'inbox',
	dataSet: [], 
	dataSetHeader: ['User Id', 'Username', 'Display Name', 'Tier', 'Contributor', 'Contributions', 'Mod', 'Posted', 'Epoch', 'Sent', 'Text', 'Appearance', 'Message Id'],
	dataTable: ['uuid', 'usernameNotPretty', 'userNotPretty', 'contribPretty.level', 'contribPretty.text', 'contribPretty.contributions', 'contribPretty.admin', 'creation.shortDate', 'timestamp', 'sentPretty', 'textPretty', 'userStylesPretty', 'id'],
	babyBear: {show: [1,7,9,10], orderBy: [[7, 'desc']]},
	mamaBear: {show: [1,2,3,7,9,10], orderBy: [[7, 'desc']]},
	papaBear: {show: ['all'], orderBy: [[7, 'desc']]},
	extraColumnDefs: [{'className': 'dt-center', 'targets': [6,9]}, {'className': 'dt-right', 'targets': [3,8]}],
	subTitle: function (){
		var html = ''
		html += sectionHeadingLeadership()
		return html 
	},
	reproduce: ['perMemberStats'],	
	reproduceSel: {perMemberStats: {selection:[0], hide:[0,1]}},	
	leadershipButton: true,
	uuidIndex: 0,
	nameIndex: 1
}

function sectionHeadingChat() {
		var html = ''
		if (group.chat.length > 0) {
			html += '<p><span class="highlight">Chat period: </span>' + group.chatTotals.firstChat.dateAndTime + ' to ' + group.chatTotals.lastChat.dateAndTime + ' (' + group.chatTotals.chatDayPeriod + ' days)</p>'
		} else {
			html +=  '<p>It appears a vow of silence has been taken, as there is no chat to report on.</p>'
		}
		return html
}
	
function sectionHeadingLastActive() {	
	var html = ''
	html += '<p>The Last Active Date is the last date of either the Last Cron, Last Chat for this '
	if (groupId == 'party') {
		html += 'party, ' // <span class="showHideToggle" data-target="memberBuffSection" data-closemainsections="true">Last Buff, Last Transformation,</span> '
	} else
	{
		html += 'guild, '
	}
	html += 'or Last Drop. A member may be active in other areas of Habitica, for example be chatting in another guild but that will not show here.</p>'
	return html
}
			
function sectionHeadingLeadership() {
		html = ''
		if ((userId == challenge.leader.id) || (userIsAdmin)) {
			var userGemAmount = user.balance * 4 
			html += '<p>To select records in bulk select the first and then hold down the shift key to select the last record. To select multiples hold down the ctrl key while selecting. </p>'
		}
		return html
}

function sectionCompletionStats() {
		html = ''
		html += 'Time Difference is represented in hours. To Do Streaks are not shown in Min/Max Streaks as there is only a Max of 1. Dailies will not record regardless if completed or missed, if participant is the inn (pause dailies is activated) at the time of cron. Dailies streaks will also not break if user completes the daily then misses one or more days and then completes a day after. '
		return html
}			
			
			
//export options	
var exportOptions = [
	{id: 'babyBear', shortDesc: 'Baby Bear', longDesc: 'Displays & exports short table format'},
	{id: 'mamaBear', shortDesc: 'Mama Bear', longDesc: 'Displays & exports medium table format'},
	{id: 'papaBear', shortDesc: 'Papa Bear', longDesc: 'Displays & exports max table format'}
];
var exportFormats = [
	{id: 0, shortDesc: 'Warm Porridge', longDesc: 'Displays & exports with Emoji & Text converted but HTML removed', convertMarkup: true, removeHtml: true, convertLineBreaks: false},
	{id: 1, shortDesc: 'Hot Porridge', longDesc: 'Displays & exports in exact Habitica HTML format', convertMarkup: true, removeHtml: false, convertLineBreaks: false},
	{id: 2, shortDesc: 'Cold Porridge', longDesc: 'Displays & exports in raw format', convertMarkup: false, removeHtml: false, convertLineBreaks: true}
];


				 
					
//////////////////////////////////////////////////////////////////////
////   Global Connection Variables      //////////////////////////////
//////////////////////////////////////////////////////////////////////
var warningMessage				= 	'PLEASE ENSURE YOUR MESSAGE IS:\n' +
									'\n\u2022 is respectful, supportive and courteous;' + 
									'\n\u2022 is not spam, including unwanted advertisements of products, social media accounts, etc;' +
									'\n\u2022 is not begging for a gift of gems or a subscription' +
									'\n\u2022 meets all requirements of the Community Guidelines of Habitica (https://habitica.com/static/community-guidelines). ' +
									'\n\u2022 meets all requirements of the Term of Service of Habitica (https://habitica.com/static/terms). ' +
									'\n' +
									'\nFailure to do so can lead to minor consequences (like warnings) to severe consequences including account bans & deletions.' +
									'\n' +
									'\nIf you have any concerns, please email Admin (admin@habitica.com) for clarification.'
var infoMessage					= 'To add a new line type {nl}.' + 
									'\nFor a paragraph break {nl}{nl}.'

var serverName					= 'Habitica'; // used in "loading" message
var serverUrl					= 'https://habitica.com/api/v3';
var serverPathContent			= '/content?language=en';
var serverPathUser				= '/user';
var serverPathChallengeForUser  = '/challenges/user'
var serverPathChallenge			= '/challenges'
var serverPathChallengeTasks	= '/tasks/challenge'

var serverPathGroup				= '/groups' //Guild associated with Challenge
var serverPathParty				= '/groups/party'
var serverPathGroupMemberPart	= '/members' //will be /groups/:groupId/members //challenge members
var serverPathMemberProfilePart	= '/members' //will be /members/:uid //
var serverMessageUser			= '/members/send-private-message'
var serverGiftGem				= '/members/transfer-gems'
var serverAwardChallenge		= 'selectWinner'  //will be /challenges/:challengeId/selectWinner 

var imageURL					= 'https://habitica-assets.s3.amazonaws.com/mobileApp/images/' 
var imageShopPrefix             =  'shop_'
var imageFileSuffix				= '.png'
var imageGem					= 'Pet_Currency_Gem1x.png'
var serverHabiticaChallenge		= 'https://habitica.com/challenges/'
var serverHabiticaProfile		= 'https://habitica.com/profile/'
var serverGDT					= 'https://oldgods.net/habitica/cTheDragons/group.html'
var hookGDT_uid					= 'uuid'
var hookGDT_groupid				= 'groupId'
var userId						= '';
var apiToken					= '';
var challengeId 				= ''; //holds selected challenge (drop down)
var groupId 					= ''; //holds group id from 
var hideAvatar					= false;
var exportOption 			 	= 'babyBear'; 
var exportFormat			 	= 1;
var challengeDropDownShow		= false;
var ajaxTryAgainMax				= 3;
var debug						= false;
var debugShowObject				= false;


if (debug || debugShowObject) serverName = '*** TURN DEBUG OFF! *** - ' + serverName
if (debug) console.log('debug 1');


var sectionOpen = ''; // holds the ID attribute of a section of the page;
                      // persists through re-fetch of data so we can
                      // reopen that section when the new data arrives
var tellMe = '<a href="https://github.com/cTheDragons">tell me</a>';

var neverDate = '1900-01-01'
var notAvailableMember = '-Member Not In Challenge-'
var noOwner = '-No Owner-'
var noUsernamePrefix = '-Unknown Username- Display Name: '

//////////////////////////////////////////////////////////////////////
////   allow Show/Hide Toggling to work    ///////////////////////////
//////////////////////////////////////////////////////////////////////
enableShowHideToggling(); // needed here to enable Version Changes link
var openRelatedSections = function(){} // redefined later when user data exists
function enableShowHideToggling() {
if (debug) console.log('debug enableShowHideToggling');

	//Populate Selector
	var htmlChallengeId = getChallengeSelectorHtml()
	var htmlExport =  getExportOptionsHtml()
	var htmlDesc =  getExportDescHtml()
	var htmlSection = getSectionDescHtml()
	
	$('#challengeSelector').html(htmlChallengeId)
	$('#exportOptionSelector').html(htmlExport)
	$('#exportOptionDesc').html(htmlDesc)
	$('#sectionDesc').html(htmlSection)

    // $('.showHideToggle').click(function(event)
	$('body').unbind('click')
    $('body').on('click', '.showHideToggle', function(event){
        var target = $(this).data("target");
        var wantToShow = (! $('#' + target).is(':visible')
                       || $(this).data("forceopen"));
            // wantToShow is false if the target is already open
            // (i.e., the user wants to close it)
            // unless the toggle's attributes force it to always be
            // opened (e.g., a link from the dashboard)
        var linktext = $(this).data("linktext") || false;
        if ($(this).data("closemainsections")) {
            $('#MAIN > *').hide();
        }
        if (wantToShow) {
            sectionOpen = target;
            $('#' + target).show();
            if (linktext) {
                $(this).text('hide ' + linktext);
            }
            openRelatedSections();
        }
        else {
            $('#' + target).hide();
            if (linktext) {
                $(this).text('show ' + linktext);
            }
            if ($(this).data("scrolltotop")) {
                window.scrollTo(0, 0);
            }
        }
        var toggleTarget = $(this).data("resettoggletext") || false;
        if (toggleTarget) {
            $('#' + toggleTarget).text('show '
                        + $('#' + toggleTarget).data("linktext"));
        }
    });
    $('body').on('click', '.mainSectionClose', function(event){
        $('#MAIN > *').hide();
        window.scrollTo(0, 0);
    });
	
	function getChallengeSelectorHtml() {
		var html = '';
		
		if (challengeDropDownShow == false) {
			html +=  '<input class="div-getChallenges" type="button" value="Get Challenges I Own" /><label><span class="formNote"> OR Enter the URL for:</span></label>'
			html +=  '<label for="challengeId"><span>Challenge ID</span>'
			html +=  '<input type="text" name="challengeId" id="challengeId"/>'
			html +=  '</label>'
		} else {
			html +=  '<input class="div-switchToManual" type="button" value="Switch to Manual Input" /><label for="challengeId"><span> OR SELECT </span></label>'
			
			html +=  '<label for="challengeId"><span>Challenge ID</span>'
			html += '<select class="challengeId" id="challengeId" name="challengeId">'
			$.each(challengeForUser, function(index, obj){	
				if (obj.leader != undefined) {
					if (userId == obj.leader.id) {
						html += '<option value="' + obj.id + '"'
						html += '>' + obj.name + '</option>';
					}
				}
			});	
			html += '</select>'
			html += '</label>'
		}
		
		return html
	}
	
	function getExportOptionsHtml() {
		var html = '';
		
		html +=  '<label for="exportOption"><span>Column Option</span>'
		html +=  '<select name="exportOption" id="exportOption">';
		$.each(exportOptions, function(index, obj){
			html += '<option value="' + obj.id + '"'
			if (obj.id == exportOption) html += ' selected '
			html += '>' + obj.shortDesc + '</option>';
		});
		html += '</select></label>'

		html +=  '<label for="exportFormat"><span>Text Format</span>'
		html +=  '<select name="exportFormat" id="exportFormat">';
		$.each(exportFormats, function(index, obj){
			html += '<option value="' + obj.id + '"'
			if (obj.id == exportFormat) html += ' selected '
			html += '>' + obj.shortDesc + '</option>';
		});
		html += '</select></label>'

		
		return html
	}
	
	function getExportDescHtml()
	{
		var html = '';
		
		html +=  '<p class="highlight">Column Options Description:</p>'
		html +=  '<ul>';
		$.each(exportOptions, function(index, obj){
			html += '<li><span class="lowlight">' + obj.shortDesc + '</span>: ' + obj.longDesc + '</li>';
		});
		html += '</ul>'

		html +=  '<p class="highlight">Text Format Description:</p>'
		html +=  '<ul>';
		$.each(exportFormats, function(index, obj){
			html += '<li><span class="lowlight">' + obj.shortDesc + '</span>: ' + obj.longDesc + '</li>';
		});
		html += '</ul>'
		
		return html
	}
	
	function getSectionDescHtml()
	{
		var html = '';
		
		$.each(sectionsToDisplay, function(index, obj){
			if (obj.type != 'heading') html += '<li><span class="subheading">' + obj.title + '</span>: ' + obj.description + '</li>';
		});
		
		return html
	}
}


//////////////////////////////////////////////////////////////////////
////   Get UUID from URL      ////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
var url_vars = getUrlVars();
if (url_vars.hasOwnProperty("userId")) {
	$("#userId").val(url_vars.userId);
} else if (url_vars.hasOwnProperty("userid")) {
	$("#userId").val(url_vars.uuid);
} else if (url_vars.hasOwnProperty("uuid")) {
	$("#userId").val(url_vars.uuid);
}
if (url_vars.hasOwnProperty("challengeId")) {
	$("#challengeId").val(url_vars.challengeId);
} else if (url_vars.hasOwnProperty("challengeid")) {
	$("#challengeId").val(url_vars.challengeId);
}
if (url_vars.hasOwnProperty("hide_avatar")) {
	if ((url_vars.hide_avatar == "checked") || (url_vars.hide_avatar == "true"))
		$("#hideAvatar").prop("checked", true);
	else {
		$("#hideAvatar").prop("checked", false);
	}
}
if (url_vars.hasOwnProperty("hide_avatars")) {
	if ((url_vars.hide_avatars == "checked") || (url_vars.hide_avatars == "true"))
		$("#hideAvatar").prop("checked", true);
	else {
		$("#hideAvatar").prop("checked", false);
	}
}
if (url_vars.hasOwnProperty("hideavatar")) {
	if ((url_vars.hideavatar == "checked") || (url_vars.hideavatar == "true"))
		$("#hideAvatar").prop("checked", true);
	else {
		$("#hideAvatar").prop("checked", false);
	}
}
if (url_vars.hasOwnProperty("hideAvatar")) {
	if ((url_vars.hideAvatar == "checked") || (url_vars.hideAvatar == "true"))
		$("#hideAvatar").prop("checked", true);
	else {
		$("#hideAvatar").prop("checked", false);
	}
}

if (url_vars.hasOwnProperty("bear")) {
		$("#exportOption").val(url_vars.bear + "Bear");
}
if (url_vars.hasOwnProperty("porridge")) {
	var selectedPorridge = exportFormat

	$.each(exportFormats, function(index, obj){
		if (url_vars.porridge == obj.shortDesc.replace(' Porridge', '').toLowerCase()) {
			selectedPorridge = obj.id;
		}
	});	
	
	$("#exportFormat").val(selectedPorridge);
}


function getUrlVars() {
    // Function found at http://stackoverflow.com/questions/4656843/jquery-get-querystring-from-url#answer-4656873
    var vars = [], hash;
    var hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
    for(var i = 0; i < hashes.length; i++)
    {
        hash = hashes[i].split('=');
        vars.push(hash[0]);
        vars[hash[0]] = hash[1];
    }
    return vars;
}


//////////////////////////////////////////////////////////////////////
////   Login events      /////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
$('#userApiDetailsForm').unbind('click')
$('#userApiDetailsForm').on('click', '.div-fetchData', function(event){
if (debug) console.log('debug #userApiDetailsForm (Fetch Data)');
	/* The user manually submitted the API connection form. */
    userId   = $('#userId').val();
    apiToken = $('#apiToken').val();
	challengeId = $('#challengeId').val();
	hideAvatar = $('#hideAvatar')[0].checked;
	exportOption = $('#exportOption').val()
    exportFormat = $('#exportFormat').val()
	if (debugShowObject) console.log('exportFormat: ' + exportFormat );

	if (debug) console.log('Challenge ID is ' +  challengeId);
	if (challengeId.length < 36) {
		$('.div-getChallenges').trigger('click');
	} else {
		challengeId = challengeId.slice(-36)

		newFetch = true ; //force table to be rebuild and memberIdSelection to be repicked
		$(document).unbind('click'); //remove random elements listeners 
		$(document).unbind('change'); //remove random elements listeners
		if (debug) console.log('Challenge ID is ' +  challengeId);
		
		fetchData();
	}
});


$('#userApiDetailsForm').on('click', '.div-getChallenges', function(event){
if (debug) console.log('debug #userApiDetailsForm (getChallenges)');

	/* The user manually submitted the API connection form. */
    userId   = $('#userId').val();
    apiToken = $('#apiToken').val();

	challengeDropDownShow = true;
	fetchChallengeForUser();
	
	
});


$('#userApiDetailsForm').on('click', '.div-switchToManual', function(event){
if (debug) console.log('debug #userApiDetailsForm (switchToManual)');

	/* The user manually submitted the API connection form. */
 	challengeDropDownShow = false;
	enableShowHideToggling()
});






//////////////////////////////////////////////////////////////////////
////   Data Fetch Functions   //////////////////////////////
//////////////////////////////////////////////////////////////////////
function fetchChallengeForUser() {
    if (debug) console.log('fetch Challenge For User Data');
	
    $('#loading #serverName').text(serverName);
    $('#loading .good').show();
    $('#loading .bad' ).hide();
	
	challengeForUser = []; // clear from previous fetches

    var ajaxRunningCount = 1; // drops to 0 when all calls have succeeded
	$('#loading #statusFetch').text('Getting Challenges for User');
    $.ajax({
        url: serverUrl + serverPathChallengeForUser,
        type: 'GET',
        dataType: 'json',
        cache: false,
        beforeSend: function(xhr){
                xhr.setRequestHeader('x-api-user', userId);
                xhr.setRequestHeader('x-api-key',  apiToken);
            },
        success: fetchChallengeForUserSuccess,
        error: fetchFailure
    });
	
	function fetchFailure(data) {
        if (debug) console.log('debug fetchFailure start');
        $('#loading .good').hide();
        $('#loading .bad' ).show();
        $('#documentationAndForm').show(); // in case user has done a re-fetch
        $('#documentationAndFormClose').hide();
		console.log(data)
        if (debug) console.log('debug fetchChallengeForUserSuccess not found');
    }
	
	function fetchChallengeForUserSuccess(data) {
        if (debug) console.log('debug parseData Challenge For User Success Start success start');
		 $('#loading .good').hide();
        challengeForUser = data.data;
		
		if (debugShowObject) console.log(challengeForUser);

		
        ajaxRunningCount--;
		
		if (ajaxRunningCount == 0) {
			enableShowHideToggling()
		}
    }
	
}

function fetchData() {
    if (debug) console.log('fetchdata');
	if (debug) console.log('Challenge ID is ' +  challengeId);
    $('#loading #serverName').text(serverName);
    $('#loading .good').show();
    $('#loading .bad' ).hide();
	
	lastListMemberId = '' // clear from previous fetches
	challenge = []; // clear from previous fetches
	challengeTasks = []; // clear from previous fetches
	group = []; // clear from previous fetches
	memberListToFetch = [];  // clear from previous fetches
	memberListToFetch_idOnly = []; // clear from previous fetches
	members = []; // clear from previous fetches
	membersChallenge = []; // clear from previous fetches
	
	var listToFetch = [];
	var lastMemberIndex = 0 // clear from previous fetches
	var lastMemberChallengeIndex = 0 // clear from previous fetches
	
    var ajaxRunningCount = 4; // drops to 0 when all calls have succeeded
	var ajaxRunningCount_Group = 1;
	var ajaxTryAgain = 0;
	var ajaxTryAgainNeed = 0;
	
    // fetch the user's own content (guilds, parties):
	$('#loading #statusFetch').text('Asking for User Data');
    $.ajax({
        url: serverUrl + serverPathUser,
        type: 'GET',
        dataType: 'json',
        cache: false,
        beforeSend: function(xhr){
                xhr.setRequestHeader('x-api-user', userId);
                xhr.setRequestHeader('x-api-key',  apiToken);
            },
        success: fetchUserSuccess,
        error: fetchFailure
    });

    // fetch the site-wide content (gear names and stats, etc):
	$('#loading #statusFetch').text('Asking for Generic Content');
    $.ajax({
        url: serverUrl + serverPathContent,
        type: 'GET',
        dataType: 'json',
        cache: true,
        success: fetchContentSuccess,
        error: fetchFailure
    });
	
    // fetch the site-wide content (gear names and stats, etc):
	$('#loading #statusFetch').text('Asking for Challenge Content');
    $.ajax({
		url: serverUrl + serverPathChallenge + '/' + challengeId,
		type: 'GET',
		dataType: 'json',
		cache: false,
		beforeSend: function(xhr){
				xhr.setRequestHeader('x-api-user', userId);
				xhr.setRequestHeader('x-api-key',  apiToken);
		},
		success: fetchChallengeSuccess,
		error: fetchFailure  //$$$ Fetch all guild data instead?
    });
	
	
	 // fetch the site-wide content (gear names and stats, etc):
	$('#loading #statusFetch').text('Asking for Challenge Content');
    $.ajax({
		url: serverUrl + serverPathChallengeTasks + '/' + challengeId,
		type: 'GET',
		dataType: 'json',
		cache: false,
		beforeSend: function(xhr){
				xhr.setRequestHeader('x-api-user', userId);
				xhr.setRequestHeader('x-api-key',  apiToken);
		},
		success: fetchChallengeTasksSuccess,
		error: fetchFailure  //$$$ Fetch all guild data instead?
    });
	
	
	function fetchFailure(ChallengeNotFound) {
        if (debug) console.log('debug fetchFailure start');
        $('#loading .good').hide();
        $('#loading .bad' ).show();
        $('#documentationAndForm').show(); // in case user has done a re-fetch
        $('#documentationAndFormClose').hide();
		console.log(ChallengeNotFound)
        if (debug) console.log('debug fetchFailure end');
    }
	
	function fetchUserSuccess(data) {
        if (debug) console.log('debug parseData User success start');
		$('#loading #statusFetch').text('Fetching User Data');
        user = data.data;
		
		if (debugShowObject) console.log(user);
		//Set userIsAdmin
		userIsAdmin = false;
		if (user.contributor != undefined) {
			if (user.contributor.admin) userIsAdmin = true
		}
		
        ajaxRunningCount--;
	
        if (ajaxRunningCount + ajaxRunningCount_Group === 0) { // all ajax calls have finished
            fetchMemberList();
        }
    }
	function fetchContentSuccess(data) {
        if (debug) console.log('debug parseData Content success start');
		$('#loading #statusFetch').text('Fetching Generic Content');
        content = data.data;
		if (debugShowObject) console.log(content);
        ajaxRunningCount--;
        if (ajaxRunningCount + ajaxRunningCount_Group === 0) { // all ajax calls have finished
            fetchMemberList();
        }
    }
  
  
	function fetchChallengeSuccess(data) {
		if (debug) console.log('debug Challenge Sucess data start');
		challenge = data.data;
		if (debugShowObject) console.log(challenge);
		
		//if (debugShowObject) console.log(groups);
		ajaxRunningCount--; 
		if (ajaxRunningCount_Group != 0) {
			
			if (challenge.group.type == 'party') 
			{	
				groupId = 'party'
				fetchPartyData(); 
			} else
			{
				groupId = challenge.group.id
				//if group id is Tavern or Newbies set group as Tavern OverFlow
				if (altChatGuild[groupId] != undefined) groupId = altChatGuild[groupId].alt
				fetchGuildData();
			}
			
		}
		if (ajaxRunningCount + ajaxRunningCount_Group  === 0) { // all ajax calls have finished
			fetchMemberList();
		}
	}		
	
	
	function fetchChallengeTasksSuccess(data) {
		if (debug) console.log('debug Challenge Task Sucess data start');
		challengeTasks = data.data;
		if (debugShowObject) console.log(challengeTasks);
		
		//if (debugShowObject) console.log(groups);
		ajaxRunningCount--; 
		if (ajaxRunningCount + ajaxRunningCount_Group  === 0) { // all ajax calls have finished
			fetchMemberList();
		}
	}	
	
	
	function fetchGuildData() {
		if (debug) console.log('debug parseData Guild Data start');
		
		$.ajax({
			url: serverUrl + serverPathGroup + '/' + groupId,
			type: 'GET',
			dataType: 'json',
			cache: false,
			beforeSend: function(xhr){
					xhr.setRequestHeader('x-api-user', userId);
					xhr.setRequestHeader('x-api-key',  apiToken);
			},
			success: fetchGuildSuccess,
			error: fetchFailure  //$$$ Fetch all guild data instead?
		});
	}
		
	function fetchGuildSuccess(data) {
		if (debug) console.log('debug Guild Sucess data start');
		group = data.data;
		if (debugShowObject) console.log(group);
		
		//if (debugShowObject) console.log(groups);
		ajaxRunningCount_Group--; 
		if (ajaxRunningCount + ajaxRunningCount_Group  === 0) { // all ajax calls have finished
			fetchMemberList();
		}
	}		
	
	function fetchPartyData() {
		if (debug) console.log('debug parseData Party Data start');
		
		$.ajax({
			url: serverUrl + serverPathParty,
			type: 'GET',
			dataType: 'json',
			cache: false,
			beforeSend: function(xhr){
					xhr.setRequestHeader('x-api-user', userId);
					xhr.setRequestHeader('x-api-key',  apiToken);
			},
			success: fetchPartySuccess,
			error: fetchFailure //$$$ Fetch all guild data instead?
		});
	}	
	
	function fetchPartySuccess(data) {
		if (debug) console.log('debug Party Sucess data start');
		party = data.data;
		group = party;
		if (debugShowObject) console.log(party);
		
		ajaxRunningCount_Group--; 
		if (ajaxRunningCount + ajaxRunningCount_Group === 0) { // all ajax calls have finished
			fetchMemberList();
		}
	}	
	
	
	
	
	
		
	
	function fetchMemberList() {
		if (debug) console.log('debug Member List start');
		$('#loading #statusFetch').text('Asking for Member List (' + memberListToFetch.length + ' so far)');
		var completeUrl = '';
		
		if (lastListMemberId == '') {
			completeUrl = serverUrl + serverPathChallenge + '/' + challengeId + serverPathGroupMemberPart ;
		} else {
			completeUrl = serverUrl + serverPathChallenge + '/' + challengeId + serverPathGroupMemberPart + '?lastId=' + lastListMemberId;
		}
		

		if (debugShowObject) console.log(completeUrl);	
		$.ajax({
			url: completeUrl,
			type: 'GET',
			dataType: 'json',
			cache: false,
			beforeSend: function(xhr){
					xhr.setRequestHeader('x-api-user', userId);
					xhr.setRequestHeader('x-api-key',  apiToken);
			},
			success: fetchMemberListSuccess,
			error: fetchMemberListFailure
		});
	}

		
		
	function fetchMemberListSuccess(data) {
		if (debug) console.log('debug Member List Sucess start');
		memberListToFetch = memberListToFetch.concat(data.data);
		
		if (memberListToFetch.length > 0) {
			if (memberListToFetch[memberListToFetch.length -1]._id == lastListMemberId || memberListToFetch.length == challenge.memberCount) {
			//The extra test as sometimes the Member Count is not accurate
				if (debugShowObject) console.log(memberListToFetch);
				fetchMembers()		 
			} else {
				//Still more members to get
				lastListMemberId = memberListToFetch[memberListToFetch.length -1]._id;
				ajaxTryAgain = 0; //Clear out previous count.
				fetchMemberList()
			}	
		} else {
			//No members in group error
			if (debug) console.log('debug Member List No one in list... WHERE DID EVERYONE GO????');
			parseData();
		}
	}	
		
	function fetchMemberListFailure() {
		if (debug) console.log('debug Member List Fail Start');
		ajaxTryAgain++
		if (ajaxTryAgain < ajaxTryAgainMax) {
			fetchMemberList()
		} else {
			fetchFailure()
		}
	}
	
	function fetchMembers(){

		
		if (ajaxTryAgainNeed > 0)  { 
			if (debug) console.log('debug MEMBER DATA - Looks like we missed some stray ducks (' + ajaxTryAgainNeed + ')');
	
			//need to find the missing members
			var ajaxTryAgainList = []
			
			$.each(memberListToFetch, function(index, obj){
				if (members[obj.id] == undefined) {
					ajaxTryAgainList.push(obj)
				} else if (membersChallenge[obj.id] == undefined) {
					ajaxTryAgainList.push(obj)
				}		
			});
			
			ajaxTryAgainNeed = 0 
			
			ajaxTryAgain++ 
			
			listToFetch = ajaxTryAgainList
			
		} else {
			if (debug) console.log('debug MEMBER DATA -Yes we are finally here folks (' + lastMemberIndex + ')');
			if (debugShowObject) console.log(memberListToFetch[lastMemberIndex].id);

			//Do a quick loop so we can check if leader is needed $$$I'm sure there is a better way but it is late
			memberListToFetch_idOnly = []
			$.each(memberListToFetch, function(index, obj){
				memberListToFetch_idOnly.push(obj.id)
			});
			
			listToFetch = memberListToFetch
		}
		
		if (debugShowObject) console.log(listToFetch.length)
		lastMemberIndex = 0
		lastMemberChallengeIndex = 0
		
		$.each(listToFetch, function(index, obj){
			$('#loading #statusFetch').text('Asking for Member Data ... (This can take a while)') ;
			if (debug) console.log('debug MEMBER DATA -Yes we are finally here folks (' + obj.id + ')');
			$.ajax({
				url: serverUrl + serverPathMemberProfilePart + '/' + obj.id,
				type: 'GET',
				dataType: 'json',
				cache: false,
				beforeSend: function(xhr){
						xhr.setRequestHeader('x-api-user', userId);
						xhr.setRequestHeader('x-api-key',  apiToken);
				},
				success: fetchMemberSuccess,
				error: fetchMemberFail
			});
			
			$.ajax({
				url: serverUrl + serverPathChallenge + '/' + challengeId + serverPathMemberProfilePart + '/' + obj.id,
				type: 'GET',
				dataType: 'json',
				cache: false,
				beforeSend: function(xhr){
						xhr.setRequestHeader('x-api-user', userId);
						xhr.setRequestHeader('x-api-key',  apiToken);
				},
				success: fetchMemberChallengeSuccess,
				error: fetchMemberChallengeFail
			});
		});
	}
		
		
	function fetchMemberFail() {
	
		if (debug) console.log('debug Member Fail Fetch for ' + (lastMemberIndex+1))
		// $$$ Put up error message?????			
		lastMemberIndex++
		if (ajaxTryAgain != ajaxTryAgainMax) ajaxTryAgainNeed++
		checkMemberAllFetch()
	}
			
			
	function fetchMemberSuccess(data) {
		if (debug) console.log('debug Member Sucess data start ' +  lastMemberIndex + '  id: ' + data.data._id);
		var friendlyMemberIndex = lastMemberIndex + 1
		$('#loading #statusFetch').text('Fetching Member '  +  friendlyMemberIndex);
		
		members[data.data._id] = data.data;

		lastMemberIndex++
		checkMemberAllFetch()
	}	
	
	function fetchMemberChallengeFail() {
		if (debug) console.log('debug Member Challenge Fail Fetch for ' + (lastMemberIndex+1))
		// $$$ Put up error message?????			
		
		lastMemberChallengeIndex++
		if (ajaxTryAgain != ajaxTryAgainMax) ajaxTryAgainNeed++
		checkMemberAllFetch()
	}
			
			
	function fetchMemberChallengeSuccess(data) {
		if (debug) console.log('debug Member Challenge Sucess data start ' +  lastMemberIndex + '  id: ' + data.data._id);
		var friendlyMemberIndex = lastMemberIndex + 1
		//$('#loading #statusFetch').text("Fetching Member's Challenge Data "  +  friendlyMemberIndex);  //Not used as it flickers too much
		membersChallenge[data.data.id] = data.data;
		
		lastMemberChallengeIndex++
		checkMemberAllFetch()
	}
	
	function checkMemberAllFetch() {
		if ((lastMemberIndex == listToFetch.length) && (lastMemberChallengeIndex == listToFetch.length)) { // all ajax calls have finished
			if (debug) console.log('debug Lost ducks ' + (ajaxTryAgainNeed))
			if (ajaxTryAgainNeed > 0) {
				fetchMembers()
			} else {	
				$('#loading #statusFetch').text('Preparing to Display the Data');
				if (debugShowObject) console.log(members);
				if (debugShowObject) console.log(membersChallenge);
				parseData();
			}
		} 
	}

}

//////////////////////////////////////////////////////////////////////
////  Post functions      //////////////////////////////
//////////////////////////////////////////////////////////////////////
// All post functions are implemented serial as they are unreliable when performed in parallel.

//////////////////////////////////////////////////////////////////////
////  Post Private Message			    //////////////////////////////
//////////////////////////////////////////////////////////////////////
function postMessageOwner() {
	if (debug) console.log('debug postMessageOwner start');
	
	var rowData = [[challenge.leader.id, challenge.leader.profile.nameNotPretty]]
	
	postMessageUser(rowData, 0, 1)
}

function postMessageUser(rowData, uuidIndex, nameIndex) {
	if (debug) console.log('debug postMessageUser start');
	if (debugShowObject) console.log(rowData)
	var urlToPost = ''	
	var actionNotificationList = ''
	var index = 0
	var privateMessage = ''
	var loopList = []
	
	if (rowData.length == 0){
		if (debug) console.log('debug no users to remove');
		alert('No row selected.\nPlease select a row before trying again.');
		return;
	
	} else {
		if (debugShowObject) console.log( rowData );
		//Check if message to be sent
		var optionalMessage = 'Thank You!'
		
		privateMessage = prompt('Please enter your private message to be sent to the users selected:\n\n' + warningMessage + '\n\n' + infoMessage, optionalMessage)

		privateMessage = privateMessage.replace(/{nl}/g,'\n');

		//get UniqueRows
		for(var i = 0; i < rowData.length; i++) {
			notInLoop = true
			
			for(var j = 0; j < loopList.length; j++) {
				if (rowData[i][uuidIndex] == loopList[j][uuidIndex]) {
					notInLoop = false
					break;
				}				
			}
			
			if (notInLoop) {
				loopList.push(rowData[i])
			}
		}
		
		for(var i = 0; i < loopList.length; i++)
		{
			actionNotificationList += '\n\u2022  ' + loopList[i][nameIndex]
		}
		
		if (privateMessage != null){
			if (confirm('Are you sure you wish to send\n\n' + privateMessage + '\n\n to the selected users?' + actionNotificationList + '\n\nThere is no undo!')){
				actionNotificationList = ''
				postNextMessageUser()
			} else {
				alert('Action cancelled')
				return;
			}
		} else {
			alert('Action cancelled')
			return;
		}
	}
	
	//This is done like this as to avoid ERR_INCOMPLETE_CHUNKED_ENCODING
	function postNextMessageUser(){
		$('#posting .good').show();
		
		obj = loopList[index]
		var newData = {message: privateMessage, toUserId: obj[uuidIndex]}
		urlToPost = serverUrl + serverMessageUser //+ '/' + obj[uuidIndex] + '?message=' + privateMessage
		$('#posting #statusPost').text('Messaging ' + obj[nameIndex] );
		if (debugShowObject) console.log(urlToPost);
		if (debugShowObject) console.log(newData);
		$.ajax({
			url: urlToPost,
			type: 'POST',
			contentType: 'application/json',
			data: JSON.stringify(newData),
			dataType: 'json',
			cache: false,
			beforeSend: function(xhr){
					xhr.setRequestHeader('x-api-user', userId);
					xhr.setRequestHeader('x-api-key',  apiToken);
				},
			success: postMessageUserSuccess,
			error: postMessageUserFailure
		});		
	}
		

	
	function postMessageUserFailure(data){
		if (debug) console.log('debug postMessageUserFailure start');
		if (debugShowObject) console.log(data);
		var errData = data;
		alert('ERROR WITH  ' +  obj[nameIndex] + '\n\n' + errData.responseJSON.error + '\n' + errData.responseJSON.message  + '\n\nPlease refetch your data and try again.');	
		index++
		
		postMessageUserCheckCompleted()
	}


	function postMessageUserSuccess(data){
		if (debug) console.log('debug postMessageUserSucess start');
		$('#posting #statusPost').text('Successfully Messaged ' + obj[nameIndex] );
		if (debugShowObject) console.log(data);
		actionNotificationList += '\n\u2022  ' + obj[nameIndex]  
		index++
		
		postMessageUserCheckCompleted()
	}
	
	function postMessageUserCheckCompleted(){
		if (index === loopList.length){
			$('#posting .good').hide();
			if (debugShowObject) console.log(actionNotificationList);
			alert('The following users have been messaged:' + actionNotificationList + '\n\nYour data will now be refreshed')
			fetchData() 
		} else
		{
			postNextMessageUser()
		}		
	
	}
}

//////////////////////////////////////////////////////////////////////
////  Post Gift Gem				    //////////////////////////////
//////////////////////////////////////////////////////////////////////
function postGiftGem(rowData, uuidIndex, nameIndex) {
	if (debug) console.log('debug postGiftGem start');
	var urlToPost = ''	
	var actionNotificationList = ''
	var gemAmount = ''
	var index = 0
	var privateMessage = ''
	var loopList = []
	
	if (rowData.length == 0){
		if (debug) console.log('debug no users to remove');
		alert('No row selected.\nPlease select a row before trying again.');
		return;
	
	} else {
		if (debugShowObject) console.log( rowData );
		//Check if message to be sent
		var optionalMessage = 'Thank You!'
		
		gemAmount = prompt('Please enter number of gems to send', '1')
		if ((gemAmount != null) && (isNaN(gemAmount) == false) && (gemAmount > 0)) {
			privateMessage = prompt('Please enter your private message to be sent to the users selected:\n\n' + warningMessage + '\n\n' + infoMessage, optionalMessage)

			privateMessage = privateMessage.replace(/{nl}/g,'\n');

			//get UniqueRows
			for(var i = 0; i < rowData.length; i++) {
				notInLoop = true
				
				for(var j = 0; j < loopList.length; j++) {
					if (rowData[i][uuidIndex] == loopList[j][uuidIndex]) {
						notInLoop = false
						break;
					}				
				}
				
				if (notInLoop) {
					loopList.push(rowData[i])
				}
			}
			
			for(var i = 0; i < loopList.length; i++)
			{
				actionNotificationList += '\n\u2022  ' + loopList[i][nameIndex]
			}
		}
		
		if ((privateMessage != null) && (gemAmount != null) && (isNaN(gemAmount) == false) && (gemAmount > 0)) {
			if (confirm('Are you sure you wish to send ' + gemAmount + ' gems with the messasge:\n\n' + privateMessage + '\n\n to the selected users?' + actionNotificationList + '\n\nThere is no undo!')){
				actionNotificationList = ''
				postNextGiftGem()
			} else {
				alert('Action cancelled')
				return;
			}
		} else {
			alert('Action cancelled')
			return;
		}
	}
	
	//This is done like this as to avoid ERR_INCOMPLETE_CHUNKED_ENCODING
	function postNextGiftGem(){
		$('#posting .good').show();
		
		obj = loopList[index]
		var newData = {message: privateMessage, toUserId: obj[uuidIndex], gemAmount: gemAmount}
		urlToPost = serverUrl + serverGiftGem //+ '/' + obj[uuidIndex] + '?message=' + privateMessage
		$('#posting #statusPost').text('Giving Gems to ' + obj[nameIndex] );
		if (debugShowObject) console.log(urlToPost);
		if (debugShowObject) console.log(newData);
		$.ajax({
			url: urlToPost,
			type: 'POST',
			contentType: 'application/json',
			data: JSON.stringify(newData),
			dataType: 'json',
			cache: false,
			beforeSend: function(xhr){
					xhr.setRequestHeader('x-api-user', userId);
					xhr.setRequestHeader('x-api-key',  apiToken);
				},
			success: postGiftGemSuccess,
			error: postGiftGemFailure
		});		
	}
		

	
	function postGiftGemFailure(data){
		if (debug) console.log('debug postGiftGemFailure start');
		if (debugShowObject) console.log(data);
		var errData = data;
		alert('ERROR WITH  ' +  obj[nameIndex] + '\n\n' + errData.responseJSON.error + '\n' + errData.responseJSON.message  + '\n\nPlease refetch your data and try again.');	
		index++
		
		postGiftGemCheckCompleted()
	}


	function postGiftGemSuccess(data){
		if (debug) console.log('debug postGiftGemSucess start');
		$('#posting #statusPost').text('Successfully Gifted Gems to ' + obj[nameIndex] );
		if (debugShowObject) console.log(data);
		actionNotificationList += '\n\u2022  ' + obj[nameIndex]  
		index++
		
		postGiftGemCheckCompleted()
	}
	
	function postGiftGemCheckCompleted(){
		if (index === loopList.length){
			$('#posting .good').hide();
			if (debugShowObject) console.log(actionNotificationList);
			alert('The following users have been gifted ' + gemAmount + ' gem(s):' + actionNotificationList + '\nwith message:\n' + privateMessage + '\n\nYour data will now be refreshed')
			fetchData() 
		} else
		{
			postNextGiftGem()
		}		
	
	}
}	

//////////////////////////////////////////////////////////////////////
////  Post Award Challenge					    //////////////////////////////
//////////////////////////////////////////////////////////////////////
function postAwardChallenge(rowData, uuidIndex, nameIndex) {
	if (debug) console.log('debug postAwardChallenge start');
	var urlToPost = ''	
	var index = 0
	var privateMessage = ''
	var loopList = []
	
	if (rowData.length == 0){
		if (debug) console.log('debug no users to remove');
		alert('No row selected.\nPlease select a row before trying again.');
		return;
	
	} else if (rowData.length > 1) {
		if (debug) console.log('debug too many leaders');
		alert('Too many row selected.\nPlease select a single row before trying again.');
		return;
	} else {
		if (debugShowObject) console.log( rowData );

		if (confirm('Are you sure to award the challenge to ' + rowData[0][nameIndex] + '\nAND\nclose the challenge?\n\nThere is no undo!')){
			obj = rowData[0]
			//newData['_id'] = groupId
			//newData['id'] = groupId
			//newData['leader'] = {}
			//newData.leader['id'] = obj[uuidIndex]
			//newData.leader['_id'] = obj[uuidIndex]
			loopList = rowData
			postNextAwardChallenge()
		} else {
			alert('Action cancelled')
			return;
		}
	}
	
	//This is done like this as to avoid ERR_INCOMPLETE_CHUNKED_ENCODING
	function postNextAwardChallenge(){
		$('#posting .good').show();
		
		obj = loopList[index]
		//var newData = {message: privateMessage, toUserId: obj[uuidIndex], gemAmount: gemAmount}
		urlToPost = serverUrl + serverPathChallenge + '/' + challengeId + '/' + serverAwardChallenge + '/' + obj[uuidIndex]
		$('#posting #statusPost').text('Awarding Challenge to ' + obj[nameIndex] );
		if (debugShowObject) console.log(urlToPost);
		$.ajax({
			url: urlToPost,
			type: 'POST',
			contentType: 'application/json',
			cache: false,
			beforeSend: function(xhr){
					xhr.setRequestHeader('x-api-user', userId);
					xhr.setRequestHeader('x-api-key',  apiToken);
				},
			success: postAwardChallengeSuccess,
			error: postAwardChallengeFailure
		});		
	}
		

	
	function postAwardChallengeFailure(data){
		if (debug) console.log('debug postAwardChallengeFailure start');
		if (debugShowObject) console.log(data);
		var errData = data;
		alert('ERROR WITH  ' +  obj[nameIndex] + '\n\n' + errData.responseJSON.error + '\n' + errData.responseJSON.message  + '\n\nPlease refetch your data and try again.');	
		
		fetchdata()
		
	}


	function postAwardChallengeSuccess(data){
		if (debug) console.log('debug postAwardChallengeSucess start');
		$('#posting #statusPost').text('Successfully Awarded ' + obj[nameIndex] );
		if (debugShowObject) console.log(data);
		$('#posting #statusPost').text('Challenge has closed.' );
		alert('The user ' + obj[nameIndex] + ' has been awarded the challenge. \n\nThe challenge has now closed')
		
	    window.location.reload(false); 
		
	}
}	


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
////  Parse Data			    //////////////////////////////
//////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////	
function parseData() {
	if (debug) console.log('debug parseData start');

	
    // variables for storing the content:
    var MAIN = {}; // each element defines the HTML for one section on the page
    var TOC  = {}; // each element defines one Table of Contents entry
    var DASHBOARD = {}; // each element defines the HTML for one dashboard tile

	var fetchtime = myDateConverter(new Date(), 'pretty');
	
	
    collateAndDisplayData(); //This is one function as memberActivty requires both Member and Guild data.

	userDataInHeader();
	groupDataInHeader();

	
	//////////////////////////////////////////////////////////////////////
    ////   Display the HTML that the functions have created   ////////////
    //////////////////////////////////////////////////////////////////////
    $('#loading #statusFetch').text('') //All Done
	$('#loading .good').hide();
	$('#posting .good').hide(); // just to be sure
    $('#documentationAndFormClose').show();
    $('#documentationAndForm').hide();
	
	formatAndDisplayDASHBOARD();
    formatAndDisplayTOC();

	if (newFetch) $('#MAIN')[0].innerHTML = ''
	if (($('#MAIN')[0].innerHTML.length > 1)) {
		//Keep previous table settings
		refreshAndDisplayMAIN([]);
	} else {
		formatAndDisplayMAIN();
	}
	
	
	//newFetch = false; //done everything now so no need to worry.
	
	if (debug) console.log('debug parseData finish');
 
	function formatAndDisplayDASHBOARD() {
		// Not required to be changed. Section controlled by Sections defined above.
		var html = '<ul>';
		var valueToDisplay = ''
		
		$.each(dashboardToDisplay, function(index, obj){
			if (obj.showOnly.length == 0 || (obj.showOnly.includes('party') && groupId == 'party') || (obj.showOnly.includes('leader') && userId == group.leader.id)){
				var data = obj;
				
				var classes = (data.hidden) ? 'hide' : '';
				html += '<li ';
				if (data.id) {
					// id is needed only if other code will change tile background
					html += 'id="' + data.id + '" ';
				}
				html += 'title="' + data.hoverText + '" ';
				if (data.target) {
					html += 'data-target="' + data.target +
							'" data-closemainsections="true" data-forceopen="true" ' +
							'class="showHideToggle ' + classes + '"';
				}
				
				valueToDisplay = eval(data.value)
				
				html += '><div class="' +
						data.status     + '"><div class="value">' +
						valueToDisplay      + '</div><div class="label">' +
						data.label      + '</div></div></li>';
			}
		});


		html += '</ul><div class="clear"></div>';
		if (debugShowObject) console.log(html);
		$('#DASHBOARD').html(html);
	}

	
	function formatAndDisplayTOC() {
		// Not required to be changed. Section controlled by Sections defined above.
		var keys = []
		var keyToAdd = ''
		
		$.each(sectionsToDisplay, function(index, obj){
			keyToAdd=''
			if (obj.showOnly.length == 0 || (obj.showOnly.includes('party') && groupId == 'party') || (obj.showOnly.includes('leader') && userId == group.leader.id)){
				if (obj.type != 'heading'){
					keyToAdd = obj.id
				} else {
					keyToAdd = 'HEADING'  
					if (obj.title != '') keyToAdd = keyToAdd + ' ' + obj.title
				}
				if (keyToAdd != '') keys.push(keyToAdd)
			}
		});
		if (debugShowObject) console.log(keys);
		
		var html = '';
		for (var i=0,ic=keys.length; i<ic; i++) {
			if (keys[i].match(/^HEADING/)) { // new section in Table of Contents
				var title = keys[i].replace(/^HEADING/, '');
				if (html) {
					html += '</ul></li>'; // close the previous section
				}
				html += '<li>' + title + (title ? ':' : '&nbsp;') + '<ul>';
			}
			else {
				var data = TOC[keys[i]];
				if (! data) {
					continue;
				}
				html += '<li class="showHideToggle" data-target="' +
						data['target'] + '" data-closemainsections="true">' +
						data['title']  + '</li>';
			}
		}
		html += '</ul></li></ul>'; // close the final section, and the parent ul
		$('#TOC').html('<ul id="tableOfContents">' + html +
					   '</ul><div class="clear"></div><hr class="padded" />');
	}

	function formatAndDisplayMAIN() {
		// Not required to be changed. Section controlled by Sections defined above.
		var keys = [];
		var keyToAdd = ''
		
		$.each(sectionsToDisplay, function(index, obj){
			keyToAdd=''
			if (obj.showOnly.length == 0 || (obj.showOnly.includes('party') && groupId == 'party') || (obj.showOnly.includes('leader') && userId == group.leader.id)){
				keyToAdd = obj.id
				if (obj.type == 'heading') keyToAdd = ''
				if (keyToAdd != '') keys.push(keyToAdd)
			}
		});
		if (debugShowObject) console.log(keys);
		
		var html = '';
		var functions = []; // functions to run after HTML code has been loaded
		var functionsPar = []; //Par to be passed in Function
		for (var i=0,ic=keys.length; i<ic; i++) {
			var data = MAIN[keys[i]];
			if (! data) {
				continue;
			}
			html += '<div id="' +
					data.id     + '"><h2>' +
					data.title  + '</h2>' +
					data.html   +
					((data.longContent) ? '<div class="mainSectionClose closer">' +
										  'close / back to top</div>' : '') +
					'</div>';
			if (data['function']) {
				functions.push(data['function']);
				functionsPar.push(data['functionPar']);
			}
		}
		$('#MAIN').html(html);
		// execute any functions that need to be run AFTER the bulk of the
		// HTML has been created:
		$.each(functions, function(index,fn){
			var passPar = functionsPar[index];
			fn(passPar);
		});
		if (sectionOpen && sectionOpen  !=  'documentationAndForm'
						&& sectionOpen  !=  'versionChanges'
		) {
			// reopen the section that the user had open before re-fetching
			// data (except for sections that don't display the user's own data):
			$('#' + sectionOpen).show();
			openRelatedSections();
		}
	}
	
	function refreshAndDisplayMAIN(sectionToRefresh) {
		// Not required to be changed. Section controlled by Sections defined above.
		var keys = [];
		var keyToAdd = ''
		
		$.each(sectionsToDisplay, function(index, obj){
			keyToAdd=''
			if (obj.showOnly.length == 0 || (obj.showOnly.includes('party') && groupId == 'party') || (obj.showOnly.includes('leader') && userId == group.leader.id)){
				keyToAdd = obj.id
				if (obj.type == 'heading') keyToAdd = ''
				if (sectionToRefresh.length != 0) {
					$.each(sectionToRefresh, function(index2, obj2){
						if (obj.id.startsWith(obj2) == false) keyToAdd = ''
					});
				}
				if (keyToAdd != '') keys.push(keyToAdd)
			}
		});
		if (debugShowObject) console.log(keys);
		
		var html = '';		
		var functions = []; // functions to run after HTML code has been loaded
		var functionsPar = []; //Par to be passed in Function
		for (var i=0,ic=keys.length; i<ic; i++) {
			var data = MAIN[keys[i]];
			if (! data) {
				continue;
			}

			html = data.refreshHtml
			$('#' + data.id + ' #' + data.refreshId).html(html)
			
			if (data['function']) {
				functions.push(data['function']);
				functionsPar.push(data['functionPar']);
			}
		}

		// execute any functions that need to be run AFTER the bulk of the
		// HTML has been created:
		$.each(functions, function(index,fn){
			var passPar = functionsPar[index];
			fn(passPar);
		});
		if (sectionOpen && sectionOpen  !=  'documentationAndForm'
						&& sectionOpen  !=  'versionChanges'
		) {
			// reopen the section that the user had open before re-fetching
			// data (except for sections that don't display the user's own data):
			$('#' + sectionOpen).show();
			openRelatedSections();
		}
	}

	openRelatedSections = function() {

	}

	function userDataInHeader() {
		var displayName = user.profile.username;
		var displayUserGemAmount = ''
		if ((userId == challenge.leader.id) || (userIsAdmin)) {
			var userGemAmount = user.balance * 4 
			displayUserGemAmount = '<span id="GemsOwned">&nbsp;&nbsp;Gems Owned: ' + userGemAmount + ' <img src="' + imageURL + imageGem + '" alt="' + 'Gem' + '"></span>' 
			
		}
		
		
		$('#headerExtras').html('<div id="userNameDisplay">' +
				displayName +
				displayUserGemAmount + 
				'</div>' +
				'<div id="explanationAndClearLinks">' +
				'<input id="refetch" type="submit" value="' +
				'Re-Fetch Data (last fetched ' + fetchtime + ')" />' +
				'<span id="documentationAndFormToggle" class="showHideToggle" data-target="documentationAndForm" data-linktext="documentation / options" data-closemainsections="true">show documentation / options</span>' +
				'</div>'  				
				
		);
		$('#refetch').click(function(event){
			/* The user clicked on the Re-Fetch My Data button. */
			newFetch = false
			$(document).unbind('click'); //remove random elements listeners
			$(document).unbind('change'); //remove random elements listeners
			fetchData();
		});
	}
	
	function groupDataInHeader() {
		var displayChallengeName = challenge.nameNotPretty;
		var displayGemAmount = challenge.prize + ' <img src="' + imageURL + imageGem + '" alt="' + 'Gem' + '">'
		var displayLeaderName = challenge.leader.profile.usernameNotPretty;
		var displayGuildName = challenge.group.nameLink;
		var displayCreated = challenge.creation.dateAndTime;
		var buttonMsgOwner = ''
		if (challenge.leader.id != userId) buttonMsgOwner = '<input id="msgOwner" type="submit" value="Message Owner" />'
		
		if (challenge.group.name != group.name) displayGuildName += ' (Guild Chat: ' + group.nameLink + ')'
		
		$('#headerGroupExtras').html('<div id="challengeNameDisplay">' + displayChallengeName + '</div>' +
				'<div id="challengeHeaderDetailDisplay">' + ' Owner: ' + displayLeaderName + 
				'&nbsp;&nbsp;&nbsp;&nbsp;<span class="showHideToggle" data-target="perMemberStatsSection" data-closemainsections="true">Prize: ' + displayGemAmount + '</span>' +
				'&nbsp;&nbsp;&nbsp;&nbsp;Created: ' + displayCreated +
				'&nbsp;&nbsp;&nbsp;&nbsp;Guild: ' + displayGuildName +
				'&nbsp;&nbsp;&nbsp;&nbsp;Id: <a href="' + serverHabiticaChallenge + challengeId + '">' + challengeId + '</a> ' +
				'&nbsp;&nbsp;&nbsp;&nbsp;' + buttonMsgOwner +
				'</div>'  
		);
		if (challenge.leader.id != userId) {
			$('#msgOwner').click(function(event){
				postMessageOwner();
			});
		}
	}
	
	//////////////////////////////////////////////////////////////////////
    ////   Formatting Functions used throughout  			  ////////////
    //////////////////////////////////////////////////////////////////////	
	
	function myDateConverter(date, style) { 

		var dateStr = '';
					
		if (style === 'pretty') {
			dateStr = moment(date).format('Do MMM YYYY, H:mm:ss');
		} else if (style === 'short') {
			if (date == neverDate) {
				dateStr = '-N/A-'
			} else {
				dateStr = moment(date).format('YYYY-MM-DD H:mm:ss');
			}
		} else if (style === 'long') {
			dateStr = moment(date).format('ddd Do MMMM YYYY, h:mm:ss a');
		} else if (style === 'utcTime') {
			dateStr = moment(date).utc().toISOString();
		} else if (style === 'epoch') {
			dateStr = moment(date).valueOf()
		} else if (style === 'relativeTime') {
			if (date == neverDate) {
				dateStr = '-N/A-'
			} else {
				dateStr = moment(date).fromNow();
			}
		}	else {
			var dateStr = moment(date).format(style);
		}
		return dateStr;
	}

	function renderFormattedText(text, options) {
		var md = window.habiticaMarkdown;
		if (text != undefined) {
			if (exportFormats[exportFormat].convertMarkup) text = md.render(text);
			if (exportFormats[exportFormat].removeHtml) text = $(text).text();
			if (exportFormats[exportFormat].convertLineBreaks) text = text.replace(/(?:\r\n|\r|\n)/g, '<br />');
			if (options && options.removeParaTags) {
				text = String(text).replace(/^<p>|<\/p>\n$/g, '');
			}
			else if (options && options.setParaClass) {
				text = String(text).replace(/<p>/g,
						   '<p class="' + options.setParaClass + '">');
			}
		}
		return text;
	}
	
	function toTitleCase(str)
	{
		return str.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
	}
	
	function constructTable(passPar) {
		//Called in Main to display table(s).
		//Will need to be added to add buttons and row selection on the fly.
		var formattedTableHeader = [];
		var dataSetSectionId = passPar[0];
		var dataSetTable = passPar[1];
		var dataSetTableHeader = passPar[2];
		var dataSetTableSection = passPar[3];
		
		var defaultShow = []
		var defaultOrderBy = []
		var buttonCollectionColumnOption = []
		var selectValue = false
		var showButtons = []
		var allColumnDefs = []
		
		var showOptions = []
		var hideOptions = []
		
		var tableExists = true
		
		if (debug) console.log('debug constructTable ' + dataSetSectionId + ' for section ' + dataSetTableSection);		
		
		
		if ($('#'+ dataSetTableSection)[0] == undefined) {
			tableExists = false
		} else {
			if ($('#'+ dataSetTableSection)[0].rows.length == 0) tableExists = false
		}

		
		
		if (tableExists) {
			if (debug) console.log ('Table exists')

			var table = $('#'+ dataSetTableSection).DataTable();

			table.clear();
			table.draw();
				
			table.rows.add(dataSetTable);
			table.draw()
			table.select.style( 'os' );

		} else {
			if (debug) console.log ('Table does not exists')
			//create column header
			$.each(dataSetTableHeader, function(index, obj){
				formattedTableHeader.push({'title': obj, 'classname': dataSetTableSection + '_' + obj.replace(/ /g, ''),  'defaultContent': ''})
			});
			
			//if (debugShowObject) console.log(formattedTableHeader);
			
			
			showButtons = formatShowButton()
			
			//if (debugShowObject) console.log(showButtons);

			allColumnDefs = [
				{ targets: defaultShow, visible: true},
				{ targets: '_all', visible: false }
			]
			allColumnDefs = allColumnDefs.concat(sectionTables[dataSetSectionId].extraColumnDefs)
			
			if (debugShowObject) console.log(allColumnDefs);

			
			sectionTables[dataSetSectionId].events = $('#events');
			$(document).ready(function() {
				sectionTables[dataSetSectionId].table = $('#'+ dataSetTableSection).DataTable( {
					data: dataSetTable,
					columns: formattedTableHeader,
					columnDefs: allColumnDefs,
					order: defaultOrderBy,
					lengthMenu: [ [10, 25, 50, 100, 200, 500, -1], [10, 25, 50, 100, 200, 500, "All"] ],
					select: selectValue, 
					dom: 'Bfrtip',
					buttons: showButtons
					
				} );
			} );
		}
		
		function formatShowButton() {
			var returnButtons = []
		
		
			//create export options
			$.each(exportOptions, function(index, obj){
				
				//Work out the hidden column list
				showOptions[obj.id] = eval('sectionTables[dataSetSectionId].' + obj.id + '.show')
				hideOptions[obj.id] = [];
				
				if (showOptions[obj.id][0] == 'all'){
					showOptions[obj.id] = []; // clear array
					for (i = 0; i < sectionTables[dataSetSectionId].dataTable.length; i++) { 
						showOptions[obj.id].push(i)
					}
					
				} else {
					for (i = 0; i < sectionTables[dataSetSectionId].dataTable.length; i++) { 
						if (showOptions[obj.id].indexOf(i) == -1) hideOptions[obj.id].push(i)
					}
				}
				buttonCollectionColumnOption.push({
									extend: 'colvisGroup',
									text: obj.shortDesc,
									show: showOptions[obj.id],
									hide: hideOptions[obj.id],
									className: 'columnGroupButton'
								})					
			});
			buttonCollectionColumnOption.push('columnsToggle')
			defaultShow = showOptions[exportOption]
			defaultOrderBy = eval('sectionTables[dataSetSectionId].' + exportOption + '.orderBy')
			
			//if (debugShowObject) console.log(showOptions);		
			//if (debugShowObject) console.log(hideOptions);	
		
			returnButtons = [
				 'pageLength', 
				 {
					extend: 'collection',
					text: 'Show/Hide',
					buttons: buttonCollectionColumnOption
				},
				{
					text: exportFormats[0].shortDesc,
					action: function ( e, dt, node, config ) {
						exportFormat = exportFormats[0].id;
						parseData();
					}
				},
				{
					text: exportFormats[1].shortDesc,
					action: function ( e, dt, node, config ) {
						exportFormat =  exportFormats[1].id;
						parseData();
					}
				},
				{
					text: exportFormats[2].shortDesc,
					action: function ( e, dt, node, config ) {
						exportFormat =  exportFormats[2].id;
						parseData();
						}
				},
				{
					extend: 'collection',
					text: 'Print/Copy/Export',
					buttons: [ 
						 {
							extend: 'print',
							exportOptions: {
								columns: ':visible'
							}
						}, {
							extend: 'copy',
							exportOptions: {
								columns: ':visible'
							}
						}, {
							extend: 'pdf',
							filename: group.name,
							exportOptions: {
								columns: ':visible'
							}	
						}, {
							extend: 'excel',
							filename: group.name,
							exportOptions: {
								columns: ':visible'
							}	
						}, {
							extend: 'csv',
							filename: group.name,
							exportOptions: {
								columns: ':visible'
							}	
						}						
					],
					autoClose: true
				}
			]
			
			//Leadership buttons
			if ((sectionTables[dataSetSectionId].leadershipButton) && ((userId == challenge.leader.id) || (userIsAdmin)) && (sectionTables[dataSetSectionId].reproduction == undefined)){
				var leadershipButton = [
					{
						text: 'Award Challenge',
						action: function ( e, dt, node, config ) {
								var rowData = sectionTables[dataSetSectionId].table.rows( { selected: true } ).data().toArray();
								var uuidIndex = sectionTables[dataSetSectionId].uuidIndex;
								var nameIndex = sectionTables[dataSetSectionId].nameIndex;
								postAwardChallenge(rowData, uuidIndex, nameIndex)	
							},
						className: 'awardChallengeButton'
					},
					{
						text: 'Gift Gems',
						action: function ( e, dt, node, config ) {
								var rowData = sectionTables[dataSetSectionId].table.rows( { selected: true } ).data().toArray();
								var uuidIndex = sectionTables[dataSetSectionId].uuidIndex;
								var nameIndex = sectionTables[dataSetSectionId].nameIndex;
								postGiftGem(rowData, uuidIndex, nameIndex)	
							},
						className: 'giftGemButton'
					},
					{
						text: 'Message User',
						action: function ( e, dt, node, config ) {
								var rowData = sectionTables[dataSetSectionId].table.rows( { selected: true } ).data().toArray();
								var uuidIndex = sectionTables[dataSetSectionId].uuidIndex;
								var nameIndex = sectionTables[dataSetSectionId].nameIndex;
								postMessageUser(rowData, uuidIndex, nameIndex)	
							},
						className: 'messageUserButton'
					}
				]
				returnButtons = returnButtons.concat(leadershipButton)
				selectValue = true
			}
			
			
			
			if (sectionTables[dataSetSectionId].extraButton != undefined) {
				var extraButton = sectionTables[dataSetSectionId].extraButton();
				returnButtons = returnButtons.concat(extraButton)
				selectValue = true
			}
			
			return returnButtons
		}
	}
		
	
	
	function constructTable_reproduce (passPar) {
		var sectionId = passPar[0];
		
		$.each(sectionsToDisplay, function(index, obj){
			if (obj.type == 'sectionTable'){
				if (sectionTables[obj.id].reproduction != undefined) {
					var newSectionId = obj.id 
					constructTable([newSectionId, sectionTables[newSectionId].dataSet, sectionTables[newSectionId].dataSetHeader, newSectionId + TABLEDISPLAYSUFFIX])
				}
			}
		});
	};	
	
	
	function constructTable_reproduce (passPar) {
		var sectionId = passPar[0];
		
		$.each(sectionsToDisplay, function(index, obj){
			if (obj.type == 'sectionTable'){
				if (obj.showOnly.length == 0 || (obj.showOnly.includes('party') && groupId == 'party') ||((obj.showOnly.includes('leader') && ((userId == challenge.leader.id) || (userIsAdmin))))){
					if (sectionTables[obj.id].reproduce != undefined) {
						if (sectionTables[obj.id].reproduce.includes(sectionId)) {
							var newSectionId = sectionId  + '_' + obj.id
							constructTable([newSectionId, sectionTables[newSectionId].dataSet, sectionTables[newSectionId].dataSetHeader, newSectionId + TABLEDISPLAYSUFFIX])

						}
					}
				}
			}
		});
	};	
	
	
	//////////////////////////////////////////////////////////////////////
    ////   Math Functions  					 ////////////
    //////////////////////////////////////////////////////////////////////
	function mean(numbers) {
	////   by Paul_Wilkins  					 ////////////
	// mean of [3, 5, 4, 4, 1, 1, 2, 3] is 2.875
		var total = 0,
			i;
		for (i = 0; i < numbers.length; i += 1) {
			total += numbers[i];
		}
		return total / numbers.length;
	}
	function median(numbers) {
	////   based on code by Paul_Wilkins  					 ////////////
		// median of [3, 5, 4, 4, 1, 1, 2, 3] = 3
		var median = 0,
			numsLen = numbers.length;
		numbers.sort(function(a, b){return a - b});
		if (numsLen % 2 === 0) { // is even
			// average of two middle numbers
			median = (numbers[numsLen / 2 - 1] + numbers[numsLen / 2]) / 2;
		} else { // is odd
			// middle number only
			median = numbers[(numsLen - 1) / 2];
		}
		return median;
	}
	function mode(numbers) {
	////   by Daniel http://danielpike.me.uk/finding-mode-element-in-an-array/ 					 ////////////

	    var mode = {};
		var max = 0, count = 0;

		numbers.forEach(function(e) {
			if (mode[e]) { mode[e]++; }
			else { mode[e] = 1; } 

			if (count<mode[e]) { 
				max = e;
				count = mode[e];
			}
		});
		
		return max;
	}
	
	function range(numbers) {
		numbers.sort(function(a, b){return a - b});
		return (String(numbers[0]) + ' to ' + String(numbers[numbers.length - 1]))
	}
	
	function smallest(numbers) {
		numbers.sort(function(a, b){return a - b});
		return (numbers[0])
	}
	
	function largest(numbers) {
		numbers.sort(function(a, b){return a - b});
		return (numbers[numbers.length - 1])
	}

	function getRandomInt(min, max) {
		//based on code from https://www.w3schools.com/js/js_random.asp
		max++ //To ensure Max can be picked
		return Math.floor(Math.random() * (max - min)) + min;
	}	
	
	//////////////////////////////////////////////////////////////////////
    ////   Collate and Display Data  					 ////////////
    //////////////////////////////////////////////////////////////////////
	function collateAndDisplayData() {
	
	
		//format collate Data -- one function
		formatAllDataAndCollate();
		
		//run functions to create for TOC / MAIN 
		$.each(sectionsToDisplay, function(index, obj){
			if (obj.type == 'sectionTable') {
				if (obj.showOnly.length == 0 || (obj.showOnly.includes('party') && groupId == 'party') || ((obj.showOnly.includes('leader') && ((userId == challenge.leader.id) || (userIsAdmin))))){
					formatTableSection(obj.id, obj.title)
				}
			} else if (obj.type == 'sectionCustom') {
				var fn = obj.functionCreate
				eval(fn + '("' + obj.id + '", "' + obj.title + '")')
			}
			
		});		
		
	
	
	//////////////////////////////////////////////////////////////////////
    ////   Prep data before using                            ////////////
	//
	//     This is where you modify data to be used throughout
	//     All data is modified here
    //////////////////////////////////////////////////////////////////////
		
		function formatAllDataAndCollate() {		
			var addToArray = []; //Used to create final array to add to dataSet
			var tempMembersList = []; //For looping through each members and adding missing variables
			var tempQuestsList = []; //For looping through each quests and adding missing variables
			var questRewardItem = {}; //For collating
			var membersTask = [];
			var membersTaskHistory = [];
			var challengeTasksRef = {};
			var chatLikes = [];
			
			
			//To complete chat stats
			var lastEphochTime = 0
			var lastEphochTime_system = 0			
			var lastEphochTime_notSystem = 0			
				
			//arrays to construct stuff because I like altering things in one place than trailing through code... (Didn't do too well with this section).	
			var attributeArrayToConstruct = ['str', 'int', 'per', 'con']
			
			var gearArrayToConstruct = ['armor', 'back', 'body', 'eyewear', 'head', 'headAccessory', 'shield', 'weapon']
						
			///////////////////////////////////////////////////////////////
			////   Single   Data                              ////////////
			//////////////////////////////////////////////////////////////
			if (debug) console.log('debug formatAllDataAndCollate Single Data Variables');
			
			
			//User
			user.profile.nameNotPretty = renderFormattedText(user.profile.name, {removeParaTags: true})
			user.profile.namePretty = renderFormattedText(user.profile.name)
			if (user.auth != undefined && user.auth.local != undefined && user.auth.local.username != undefined) {
				user.profile.username = user.auth.local.username 
			} else {
				user.profile.username = noUsernamePrefix + user.profile.name
			}
			
			//challenge
			challenge.nameNotPretty = renderFormattedText(challenge.name, {removeParaTags: true})
			challenge.namePretty = renderFormattedText(challenge.name)

			if (challenge.leader != undefined) {
				challenge.leader.profile.nameNotPretty = '<a href="' + serverHabiticaProfile + challenge.leader.id + '" target="_blank">' + renderFormattedText(challenge.leader.profile.name, {removeParaTags: true}) + '</a>'
				challenge.leader.profile.namePretty = '<a href="' + serverHabiticaProfile + challenge.leader.id + '" target="_blank">' + renderFormattedText(challenge.leader.profile.name) + '</a>'
				if (challenge.leader.auth.local.username != undefined) {
					challenge.leader.profile.usernameNotPretty = '<a href="' + serverHabiticaProfile + challenge.leader.id + '" target="_blank">' + challenge.leader.auth.local.username + '</a>'
				} else {
					challenge.leader.profile.usernameNotPretty = '<a href="' + serverHabiticaProfile + challenge.leader.id + '" target="_blank">' + noUsernamePrefix + challenge.leader.profile.name + '</a>'
				}
				challenge.leader.profile.usernamePretty = challenge.leader.profile.usernameNotPretty 
			} else {
				challenge.leader = {}
				challenge.leader.profile = {}
				challenge.leader.profile.name = noOwner
				challenge.leader.id = noOwner
				challenge.leader.profile.nameNotPretty = noOwner
				challenge.leader.profile.namePretty =  noOwner
				challenge.leader.profile.usernameNotPretty = noOwner
				challenge.leader.profile.usernamePretty = noOwner
			}
			
			
			challenge.group.nameNotPretty = renderFormattedText(challenge.group.name, {removeParaTags: true})
			challenge.group.nameLink = '<a href="' + serverGDT + '?' + hookGDT_uid + '=' + userId + '&' + hookGDT_groupid + '=' + challenge.group.id + '" target="_blank">' + renderFormattedText(challenge.group.name, {removeParaTags: true}) + '</a>'
			challenge.group.namePretty = renderFormattedText(challenge.group.name)
			challenge.creation = reformatDate(challenge.createdAt)
			
			challenge.memberTotals = {}
			challenge.memberTotals.fetchCount = 0 //to populate later
			challenge.memberTotals.inInn = 0 //to populate later
			challenge.memberTotals.activeLess12Hr = 0 //to populate later
			challenge.memberTotals.activeLess24Hr = 0 //to populate later
			challenge.memberTotals.activeLessWeek = 0 //to populate later
			challenge.memberTotals.activeLessMonth = 0 //to populate later
//			if (groupId == 'party')	group.quest.memberCount = 0 //to populate later
			challenge.memberTotals.inInn_activeLess12Hr = 0 //to populate later
			challenge.memberTotals.inInn_activeLess24Hr = 0 //to populate later
			challenge.memberTotals.inInn_activeLessWeek = 0 //to populate later
			challenge.memberTotals.inInn_activeLessMonth = 0 //to populate later
			challenge.memberTotals.class = {}
			challenge.memberTotals.class.warrior = 0 //to populate later
			challenge.memberTotals.class.wizard = 0 //to populate later
			challenge.memberTotals.class.rogue = 0 //to populate later
			challenge.memberTotals.class.healer = 0 //to populate later
			challenge.memberTotals.underLevel10 = 0 //to populate later
			
			//Dashboard stats for Challenge
			challenge.challengeStats = {}
			challenge.challengeStats.count = 0
			challenge.challengeStats.countPositive = 0
			challenge.challengeStats.countNegative = 0
			challenge.challengeStats.countNotDue = 0
			
			challenge.challengeStats.first = reformatDate(neverDate)
			challenge.challengeStats.last = reformatDate(neverDate)
			
			challenge.challengeStats.activeLess12Hr = 0 //to populate later
			challenge.challengeStats.activeLess24Hr = 0 //to populate later
			challenge.challengeStats.activeLessWeek = 0 //to populate later
			challenge.challengeStats.activeLessMonth = 0 //to populate later

			challenge.challengeStats.inInn_activeLess12Hr = 0 //to populate later
			challenge.challengeStats.inInn_activeLess24Hr = 0 //to populate later
			challenge.challengeStats.inInn_activeLessWeek = 0 //to populate later
			challenge.challengeStats.inInn_activeLessMonth = 0 //to populate later
			
			challenge.taskTotals = {}
			challenge.taskTotals.overall = 0
			challenge.taskTotals.todo = 0
			challenge.taskTotals.habit = 0
			challenge.taskTotals.daily = 0
			challenge.taskTotals.reward = 0
			
			//Group
			group.nameNotPretty = renderFormattedText(group.name, {removeParaTags: true})
			group.nameLink = '<a href="' + serverGDT + '?' + hookGDT_uid + '=' + userId + '&' + hookGDT_groupid + '=' + group.id + '" target="_blank">' + renderFormattedText(group.name, {removeParaTags: true}) + '</a>'
			group.namePretty = renderFormattedText(group.name)
			group.leader.profile.nameNotPretty = renderFormattedText(group.leader.profile.name, {removeParaTags: true})
			group.leader.profile.namePretty = renderFormattedText(group.leader.profile.name)
//			if (groupId == 'party')	{
//				group.quest.inInn_memberCount = 0 //to populate later
//				group.quest.damageTotal = 0 //to populate later
//				group.quest.damageTotalCurrent = 0 //to populate later
//				group.quest.damageTotalPrevious = 0 //to populate later
//				group.quest.damageBoss = 0 //to populate later
//				group.quest.damageBossCurrent = 0 //to populate later
//				group.quest.damageBossPrevious = 0 //to populate later
//				group.quest.collectionTotalCurrent = 0 //to populate later
//				group.quest.collectionTotalPrevious = 0 //to populate later
//				if (group.quest.active) {
//					 noQuestsInChat = 0
//				} else {
//					noQuestsInChat = -1
//				}
//			}
			group.chatTotals = {}
			group.chatTotals.count_notSystem = 0 //to populate later
			group.chatTotals.count_system = 0 //to populate later
			group.chatTotals.timePeriod = []
			group.chatTotals.timePeriod_notSystem = []
			group.chatTotals.timePeriod_system = []		
			group.chatTotals.firstChat  = reformatDate(neverDate)
			group.chatTotals.lastChat  = reformatDate(neverDate)
			
			// Loop through all tasks items to add all items to be populated 
			$.each(challengeTasks, function(index, obj){
				challengeTasksRef[obj.id] = index;
				modifyTaskProperties(obj); //Might well do it now.
				
				//Do Count as we are doing everything here too.
				challenge.taskTotals.overall++
				challenge.taskTotals[obj.type]++
				
				
				obj.challengeStats = {}
				
				obj.challengeStats.streak = {}
				obj.challengeStats.streak.min = undefined
				obj.challengeStats.streak.max = undefined
				obj.challengeStats.streakNeg = {}
				obj.challengeStats.streakNeg.min = undefined
				obj.challengeStats.streakNeg.max = undefined

				obj.challengeStats.first = reformatDate(neverDate)
				obj.challengeStats.last = reformatDate(neverDate)
				obj.challengeStats.count = 0
				obj.challengeStats.countPositive = 0
				obj.challengeStats.countNegative = 0
				obj.challengeStats.countNotDue = 0
				
				obj.challengeStats.timeDiffMin = {}
				obj.challengeStats.timeDiffMax = {}
				obj.challengeStats.timeDiffMin.overall = undefined
				obj.challengeStats.timeDiffMax.overall = undefined
				obj.challengeStats.timeDiffMin.todo = undefined
				obj.challengeStats.timeDiffMax.todo = undefined
				obj.challengeStats.timeDiffMin.habit = undefined
				obj.challengeStats.timeDiffMax.habit = undefined
				obj.challengeStats.timeDiffMin.daily = undefined
				obj.challengeStats.timeDiffMax.daily = undefined


				obj.challengeStats.valueDiffMin = {}
				obj.challengeStats.valueDiffMax = {}
				obj.challengeStats.valueDiffMin.overall= undefined
				obj.challengeStats.valueDiffMax.overall = undefined
				obj.challengeStats.valueDiffMin.todo = undefined
				obj.challengeStats.valueDiffMax.overall_todo = undefined
				obj.challengeStats.valueDiffMin.habit = undefined
				obj.challengeStats.valueDiffMax.overall_habit = undefined
				obj.challengeStats.valueDiffMin.daily = undefined
				obj.challengeStats.valueDiffMax.overall_daily = undefined
				
				
			});
			
			// Loop through all members to add all items to be populated (avoid messy undefines later)
			$.each(memberListToFetch, function(index, obj){
				members[obj.id].lastChat = {}
				members[obj.id].lastChat.text = ''
				members[obj.id].lastChat.textPretty = ''
				members[obj.id].lastChat.occured = reformatDate(neverDate)
				members[obj.id].lastChat.countTotal = 0
				members[obj.id].lastChat.countLess12Hr = 0
				members[obj.id].lastChat.countLess24Hr = 0
				
				members[obj.id].challengeStats = {}
				members[obj.id].challengeStats.joined = reformatDate(neverDate)
				
				members[obj.id].challengeStats.streak = {}
				members[obj.id].challengeStats.streak.min = undefined
				members[obj.id].challengeStats.streak.max = undefined
				members[obj.id].challengeStats.streakNeg = {}
				members[obj.id].challengeStats.streakNeg.min = undefined
				members[obj.id].challengeStats.streakNeg.max = undefined

				members[obj.id].challengeStats.first = reformatDate(neverDate)
				members[obj.id].challengeStats.last = reformatDate(neverDate)
				members[obj.id].challengeStats.count = 0
				members[obj.id].challengeStats.countPositive = 0
				members[obj.id].challengeStats.countNegative = 0
				members[obj.id].challengeStats.countNotDue = 0
				
				members[obj.id].challengeStats.timeDiffMin = {}
				members[obj.id].challengeStats.timeDiffMax = {}
				members[obj.id].challengeStats.timeDiffMin.overall = undefined
				members[obj.id].challengeStats.timeDiffMax.overall = undefined
				members[obj.id].challengeStats.timeDiffMin.todo = undefined
				members[obj.id].challengeStats.timeDiffMax.todo = undefined
				members[obj.id].challengeStats.timeDiffMin.habit = undefined
				members[obj.id].challengeStats.timeDiffMax.habit = undefined
				members[obj.id].challengeStats.timeDiffMin.daily = undefined
				members[obj.id].challengeStats.timeDiffMax.daily = undefined


				members[obj.id].challengeStats.valueDiffMin = {}
				members[obj.id].challengeStats.valueDiffMax = {}
				members[obj.id].challengeStats.valueDiffMin.overall= undefined
				members[obj.id].challengeStats.valueDiffMax.overall = undefined
				members[obj.id].challengeStats.valueDiffMin.todo = undefined
				members[obj.id].challengeStats.valueDiffMax.overall_todo = undefined
				members[obj.id].challengeStats.valueDiffMin.habit = undefined
				members[obj.id].challengeStats.valueDiffMax.overall_habit = undefined
				members[obj.id].challengeStats.valueDiffMin.daily = undefined
				members[obj.id].challengeStats.valueDiffMax.overall_daily = undefined
				
				//Need to keep this although not calculated					
				members[obj.id].lastBuff = {}
				members[obj.id].lastBuff.occured = reformatDate(neverDate)
				members[obj.id].lastBuff.countTotal = 0
				members[obj.id].lastBuff.countLess12Hr = 0
				members[obj.id].lastBuff.countLess24Hr = 0

				members[obj.id].lastTransformation = {}
				members[obj.id].lastTransformation.occured = reformatDate(neverDate)
				members[obj.id].lastTransformation.countTotal = 0
				members[obj.id].lastTransformation.countLess12Hr = 0
				members[obj.id].lastTransformation.countLess24Hr = 0
/*
				members[obj.id].quest = {}
				members[obj.id].quest.damageTotal = 0
				members[obj.id].quest.damageTotalCurrent = 0
				members[obj.id].quest.damageTotalPrevious = 0
				members[obj.id].quest.damageBoss = 0
				members[obj.id].quest.damageBossCurrent = 0
				members[obj.id].quest.damageBossPrevious = 0
				members[obj.id].quest.collectionTotal = 0
				members[obj.id].quest.collectionTotalCurrent = 0
				members[obj.id].quest.collectionTotalPrevious = 0
*/					
			});
			
			
			
			///////////////////////////////////////////////////////////////
			////   Process Sections / Table / Count Values     ////////////
			//////////////////////////////////////////////////////////////
			if (debug) console.log('debug formatAllDataAndCollate Secion/tableData');
			
			//Clear arrays
			$.each(sectionsToDisplay, function(index, obj){
				if (obj.type == 'sectionTable'){
					sectionTables[obj.id].dataSet=[];
				}
			});
			
			
			
			//chat data format and collate
			if (debugShowObject) console.log(sectionTables);
			
			
			
			///////////////////////////////////////////////////////////////
			////   Chat Section                                ////////////
			//////////////////////////////////////////////////////////////
			$.each(group.chat, function(index, obj){
				
				modifyChatProperties(obj);
								
				//Add in participation dates
				//assuming travelling from last to earliest
				if (members[obj.uuid]  !=  undefined) {
					members[obj.uuid].lastChat.countTotal++
					if (moment().subtract(12, 'hours').isBefore(obj.creation.utcTime)) members[obj.uuid].lastChat.countLess12Hr++
					if (moment().subtract(24, 'hours').isBefore(obj.creation.utcTime)) members[obj.uuid].lastChat.countLess24Hr++
					
					if (members[obj.uuid].lastChat.occured.utcTime < obj.creation.utcTime) {
						members[obj.uuid].lastChat.text = obj.text
						members[obj.uuid].lastChat.textPretty = obj.textPretty
						members[obj.uuid].lastChat.occured = obj.creation
					} 
				}				
				
				
				//Date Times, counts etc
				if (lastEphochTime != 0) group.chatTotals.timePeriod.push(lastEphochTime-obj.timestamp);
				lastEphochTime = obj.timestamp
				
				if (obj.uuid != 'system') 
				{	
					group.chatTotals.count_notSystem++
					
					if (lastEphochTime_notSystem != 0) group.chatTotals.timePeriod_notSystem.push(lastEphochTime_notSystem-obj.timestamp);
					lastEphochTime_notSystem = obj.timestamp

				} else {
					group.chatTotals.count_system++
					
					if (lastEphochTime_system != 0) group.chatTotals.timePeriod_system.push(lastEphochTime_system-obj.timestamp);
					lastEphochTime_system = obj.timestamp
				}
				
				if (group.chatTotals.firstChat.utcTime != myDateConverter(neverDate, 'utcTime')){
					if (moment(obj.creation.utcTime).isBefore(group.chatTotals.firstChat.utcTime)) group.chatTotals.firstChat = obj.creation
				} else {
					group.chatTotals.firstChat = obj.creation
				}
				if (group.chatTotals.lastChat.utcTime != myDateConverter(neverDate, 'utcTime')){
					if (moment(obj.creation.utcTime).isAfter(group.chatTotals.lastChat.utcTime)) group.chatTotals.lastChat = obj.creation
				} else {
					group.chatTotals.lastChat = obj.creation
				}
				
				//Chat Likes
				obj.likeCount = {}
				obj.likeCount.total = 0
				obj.likeCount.totalInChallenge = 0
				
				$.each(obj.likes, function(index2, obj2){
					if (obj2) {
						obj.likeCount.total++
						if (members[index2] != undefined){
							obj.likeCount.totalInChallenge++
						} 
						addToArray = {};
						addToArray = {member: members[index2], chat: obj, id: index2}
						chatLikes.push(addToArray)
					}
				});
				
				$.each(sectionsToDisplay, function(index2, obj2){
					if (obj2.type == 'sectionTable' && (obj2.showOnly.includes('party') != true || groupId == 'party')) {
						if (sectionTables[obj2.id].type == 'chat'){
							addToArray = []; //clear array
							$.each(sectionTables[obj2.id].dataTable, function(index3, obj3){
								addToArray.push(eval('obj.' + obj3))
							});
							//Don't include system messages if chatNotSystemExport
							if ((obj.uuid != 'system' && obj2.id == 'chatNotSystemExport') || (obj.uuid == 'system' && obj2.id == 'chatSystemExport') || (obj2.id != 'chatNotSystemExport' && obj2.id != 'chatSystemExport')) sectionTables[obj2.id].dataSet.push(addToArray); 
						}
						
					}
				});
			}); 
			if (debugShowObject) console.log(chatLikes);
						
			if (debug) console.log('Finish collating chatExportSet');
			group.chatTotals.chatDayPeriod = (Math.round((moment(group.chatTotals.lastChat.utcTime).diff(moment(group.chatTotals.firstChat.utcTime), 'hours'))/24*100)/100) 


						
			
			
			///////////////////////////////////////////////////////////////
			////   Member First Process  (not add)           ////////////
			//////////////////////////////////////////////////////////////
			//Create simple array to pop from (not a named Array)
			$.each(memberListToFetch, function(index, obj){
				modifyUserProperties(members[obj.id]);
			
				challenge.memberTotals.fetchCount++
				
				//Merge in Challenge Data?
				
			
				//Add in missing variables
				if (members[obj.id].lastChat == undefined) {
					members[obj.id].lastChat = {}
					members[obj.id].lastChat.text = ''
					members[obj.id].lastChat.textPretty = ''
					members[obj.id].lastChat.occured = reformatDate(neverDate)
					members[obj.id].lastChat.totalLines = 0
				}
				
				//Attribute Calculates
				members[obj.id].attributeTotals = {}
				$.each(attributeArrayToConstruct, function (index2, obj2){
					members[obj.id].attributeTotals[obj2] = {};
					if (members[obj.id].stats.lvl < 100) {
						members[obj.id].attributeTotals[obj2].lvl = Math.floor(members[obj.id].stats.lvl / 2)
					} else {
						members[obj.id].attributeTotals[obj2].lvl = Math.floor(100 / 2)
					};
					members[obj.id].attributeTotals[obj2].buff = members[obj.id].stats.buffs[obj2]
					members[obj.id].attributeTotals[obj2].allocated = members[obj.id].stats[obj2]
					members[obj.id].attributeTotals[obj2].gear = 0
					members[obj.id].attributeTotals[obj2].gearBuff = 0
					$.each(gearArrayToConstruct, function (index3, obj3){
						if (members[obj.id].items.gear.equipped[obj3] != undefined) {
							var gearKey = members[obj.id].items.gear.equipped[obj3]
							if (content.gear.flat[gearKey] != undefined) {
								members[obj.id].attributeTotals[obj2].gear += content.gear.flat[gearKey][obj2]
								if (content.gear.flat[gearKey].klass == members[obj.id].stats.class || content.gear.flat[gearKey].specialClass == members[obj.id].stats.class ) members[obj.id].attributeTotals[obj2].gearBuff += content.gear.flat[gearKey][obj2] / 2
							}
						}
					});
					members[obj.id].attributeTotals[obj2].total = members[obj.id].attributeTotals[obj2].lvl + members[obj.id].attributeTotals[obj2].buff + members[obj.id].attributeTotals[obj2].allocated + members[obj.id].attributeTotals[obj2].gear + members[obj.id].attributeTotals[obj2].gearBuff
				});
				

				//Class Stats
				challenge.memberTotals.class[members[obj.id].stats.classPretty]++
				if (members[obj.id].stats.lvl < 11) challenge.memberTotals.underLevel10++
				
			
				//Calculate task information.
				$.each(membersChallenge[obj.id].tasks, function(index2, obj2){
					var challengeTaskIndex = challengeTasksRef[obj2.challenge.taskId]
					modifyTaskProperties(obj2)



					obj2.checklistComp = {}
					obj2.checklistComp.fullList = ''
					obj2.checklistComp.fullListPretty = ''
					obj2.checklistComp.fullListNotPretty = ''
					var checkSymbol  = ''
					$.each(obj2.checklist, function(index3, obj3){
						if (obj3.completed) { 
							checkSymbol = '&#9745'
						} else {
							checkSymbol = '&#9744'
						}
						if (obj2.checklistComp.fullList != '') checkSymbol = '<br />' + checkSymbol
						obj2.checklistComp.fullList += checkSymbol + '&nbsp;&nbsp;' + obj3.text
						obj2.checklistComp.fullListPretty += checkSymbol + '&nbsp;&nbsp;' + renderFormattedText(obj3.text)
						obj2.checklistComp.fullListNotPretty += checkSymbol + '&nbsp;&nbsp;' + renderFormattedText(obj3.text, {removeParaTags: true})
					});
					
					obj2.challengeStats = {}
					
					obj2.challengeStats.streak = {}
					obj2.challengeStats.streak.current = 0
					obj2.challengeStats.streak.min = undefined
					obj2.challengeStats.streak.max = undefined
					obj2.challengeStats.streakNeg = {}
					obj2.challengeStats.streakNeg.current = 0
					obj2.challengeStats.streakNeg.min = undefined
					obj2.challengeStats.streakNeg.max = undefined
					obj2.challengeStats.first = reformatDate(neverDate)
					obj2.challengeStats.last = reformatDate(neverDate)
					obj2.challengeStats.count = 0
					obj2.challengeStats.countPositive = 0
					obj2.challengeStats.countNegative = 0
					obj2.challengeStats.countNotDue = 0
					
					obj2.challengeStats.timeDiffMin = undefined
					obj2.challengeStats.timeDiffMax = undefined
					obj2.challengeStats.valueDiffMin = undefined
					obj2.challengeStats.valueDiffMax = undefined

				
					
					if ((members[obj.id].challengeStats.joined.utcTime > obj2.creation.utcTime) || (members[obj.id].challengeStats.joined.utcTime == myDateConverter(neverDate, 'utcTime'))) members[obj.id].challengeStats.joined = obj2.creation
					
					
					if (obj2.history == undefined) {
						obj2.history = []
					}
					
					if (obj2.completed) {
						if (obj2.dateCompleted != undefined) {
							var tempDate = myDateConverter(obj2.dateCompleted, 'epoch')
						} else {
							var tempDate = myDateConverter(obj2.updatedAt, 'epoch')
							//daily $$$ADd another variable here?
						}
					
						addToArray = {};
						addToArray = {date: tempDate, value: obj2.value}
						if (obj2.history.length == 0) obj2.history.push(addToArray)						
					}
				

					var tempValuePrev = 0
					var tempDatePrev = obj2.creation
					var firstRun = true
					
					$.each(obj2.history, function(index3, obj3){
						modifyTaskHistoryProperties(obj3)
						
						if (obj2.type == 'habit') {
							if (obj3.scoredUp == undefined) obj3.scoredUp = 0 //Maybe we should check values if up or down but the is old data.
							if (obj3.scoredDown == undefined) obj3.scoredDown = 0 //Maybe we should check values if up or down but the is old data.
						
							obj3.clickup = obj3.scoredUp
							obj3.clickdown = obj3.scoredDown
							obj3.total = obj3.scoredUp + obj3.scoredDown

							obj2.challengeStats.countPositive += obj3.clickup
							members[obj.id].challengeStats.countPositive += obj3.clickup
							if (challengeTasks[challengeTaskIndex] != undefined) challengeTasks[challengeTaskIndex].challengeStats.countPositive += obj3.clickup
							challenge.challengeStats.countPositive += obj3.clickup
							
							obj2.challengeStats.countNegative += obj3.clickdown
							members[obj.id].challengeStats.countNegative += obj3.clickdown
							if (challengeTasks[challengeTaskIndex] != undefined) challengeTasks[challengeTaskIndex].challengeStats.countNegative += obj3.clickdown
							challenge.challengeStats.countNegative += obj3.clickdown

							if (obj3.clickdown == 0) {
								obj2.challengeStats.streak.current += obj3.clickup
							} else if (obj3.clickup == 0) {
								obj2.challengeStats.streakNeg.current += obj3.clickdown		
							}
							
							if (obj3.clickup != 0) {
								if (((obj2.challengeStats.streakNeg.min == undefined) || (obj2.challengeStats.streakNeg.min > obj2.challengeStats.streakNeg.current)) && (obj2.challengeStats.streakNeg.current != 0)) obj2.challengeStats.streakNeg.min = obj2.challengeStats.streakNeg.current  
								if (obj2.type != 'todo') if (((members[obj.id].challengeStats.streakNeg.min == undefined) || (members[obj.id].challengeStats.streakNeg.min > obj2.challengeStats.streakNeg.current)) && (obj2.challengeStats.streakNeg.current != 0)) members[obj.id].challengeStats.streakNeg.min = obj2.challengeStats.streakNeg.current  
								if (challengeTasks[challengeTaskIndex] != undefined) if (obj2.type != 'todo') if (((challengeTasks[challengeTaskIndex].challengeStats.streakNeg.min == undefined) || (challengeTasks[challengeTaskIndex].challengeStats.streakNeg.min > obj2.challengeStats.streakNeg.current)) && (obj2.challengeStats.streakNeg.current != 0)) challengeTasks[challengeTaskIndex].challengeStats.streakNeg.min = obj2.challengeStats.streakNeg.current  
								if ((obj2.challengeStats.streakNeg.max == undefined) || (obj2.challengeStats.streakNeg.max < obj2.challengeStats.streakNeg.current)) obj2.challengeStats.streakNeg.max = obj2.challengeStats.streakNeg.current  
								if (obj2.type != 'todo') if ((members[obj.id].challengeStats.streakNeg.max == undefined) || (members[obj.id].challengeStats.streakNeg.max < obj2.challengeStats.streakNeg.current)) members[obj.id].challengeStats.streakNeg.max = obj2.challengeStats.streakNeg.current  
								if (challengeTasks[challengeTaskIndex] != undefined) if (obj2.type != 'todo') if ((challengeTasks[challengeTaskIndex].challengeStats.streakNeg.max == undefined) || (challengeTasks[challengeTaskIndex].challengeStats.streakNeg.max < obj2.challengeStats.streakNeg.current)) challengeTasks[challengeTaskIndex].challengeStats.streakNeg.max = obj2.challengeStats.streakNeg.current  

								obj2.challengeStats.streakNeg.current = 0						
							}
							
							if (obj3.clickdown != 0) {
								if (((obj2.challengeStats.streak.min == undefined) || (obj2.challengeStats.streak.min > obj2.challengeStats.streak.current)) && (obj2.challengeStats.streak.current != 0)) obj2.challengeStats.streak.min = obj2.challengeStats.streak.current  
								if (obj2.type != 'todo') if (((members[obj.id].challengeStats.streak.min == undefined) || (members[obj.id].challengeStats.streak.min > obj2.challengeStats.streak.current)) && (obj2.challengeStats.streak.current != 0)) members[obj.id].challengeStats.streak.min = obj2.challengeStats.streak.current  
								if (challengeTasks[challengeTaskIndex] != undefined) if (obj2.type != 'todo') if (((challengeTasks[challengeTaskIndex].challengeStats.streak.min == undefined) || (challengeTasks[challengeTaskIndex].challengeStats.streak.min > obj2.challengeStats.streak.current)) && (obj2.challengeStats.streak.current != 0)) challengeTasks[challengeTaskIndex].challengeStats.streak.min = obj2.challengeStats.streak.current  
								if ((obj2.challengeStats.streak.max == undefined) || (obj2.challengeStats.streak.max < obj2.challengeStats.streak.current)) obj2.challengeStats.streak.max = obj2.challengeStats.streak.current  
								if (obj2.type != 'todo') if ((members[obj.id].challengeStats.streak.max == undefined) || (members[obj.id].challengeStats.streak.max < obj2.challengeStats.streak.current)) members[obj.id].challengeStats.streak.max = obj2.challengeStats.streak.current  
								if (challengeTasks[challengeTaskIndex] != undefined) if (obj2.type != 'todo') if ((challengeTasks[challengeTaskIndex].challengeStats.streak.max == undefined) || (challengeTasks[challengeTaskIndex].challengeStats.streak.max < obj2.challengeStats.streak.current)) challengeTasks[challengeTaskIndex].challengeStats.streak.max = obj2.challengeStats.streak.current  
									
								obj2.challengeStats.streak.current = 0
							}
							

						} else {
						
							obj3.total = 1
						
							if ((obj3.value > tempValuePrev && !(obj2.type == 'habit' && obj2.up == false)) ||  (obj2.type == 'habit' && obj2.down == false) ||  (obj2.type == 'todo') || ((obj3.value == tempValuePrev) && (obj2.type != 'daily'))) {
								obj3.clickup = 1
								obj3.clickdown = 0

								obj2.challengeStats.countPositive += 1
								members[obj.id].challengeStats.countPositive += 1
								if (challengeTasks[challengeTaskIndex] != undefined) challengeTasks[challengeTaskIndex].challengeStats.countPositive += 1
								challenge.challengeStats.countPositive += 1
								obj2.challengeStats.streak.current += 1
								
								
								if (((obj2.challengeStats.streakNeg.min == undefined) || (obj2.challengeStats.streakNeg.min > obj2.challengeStats.streakNeg.current)) && (obj2.challengeStats.streakNeg.current != 0)) obj2.challengeStats.streakNeg.min = obj2.challengeStats.streakNeg.current  
								if (obj2.type != 'todo') if (((members[obj.id].challengeStats.streakNeg.min == undefined) || (members[obj.id].challengeStats.streakNeg.min > obj2.challengeStats.streakNeg.current)) && (obj2.challengeStats.streakNeg.current != 0)) members[obj.id].challengeStats.streakNeg.min = obj2.challengeStats.streakNeg.current  
								if (challengeTasks[challengeTaskIndex] != undefined) if (obj2.type != 'todo') if (((challengeTasks[challengeTaskIndex].challengeStats.streakNeg.min == undefined) || (challengeTasks[challengeTaskIndex].challengeStats.streakNeg.min > obj2.challengeStats.streakNeg.current)) && (obj2.challengeStats.streakNeg.current != 0)) challengeTasks[challengeTaskIndex].challengeStats.streakNeg.min = obj2.challengeStats.streakNeg.current  
								if ((obj2.challengeStats.streakNeg.max == undefined) || (obj2.challengeStats.streakNeg.max < obj2.challengeStats.streakNeg.current)) obj2.challengeStats.streakNeg.max = obj2.challengeStats.streakNeg.current  
								if (obj2.type != 'todo') if ((members[obj.id].challengeStats.streakNeg.max == undefined) || (members[obj.id].challengeStats.streakNeg.max < obj2.challengeStats.streakNeg.current)) members[obj.id].challengeStats.streakNeg.max = obj2.challengeStats.streakNeg.current  
								if (challengeTasks[challengeTaskIndex] != undefined) if (obj2.type != 'todo') if ((challengeTasks[challengeTaskIndex].challengeStats.streakNeg.max == undefined) || (challengeTasks[challengeTaskIndex].challengeStats.streakNeg.max < obj2.challengeStats.streakNeg.current)) challengeTasks[challengeTaskIndex].challengeStats.streakNeg.max = obj2.challengeStats.streakNeg.current  

								obj2.challengeStats.streakNeg.current = 0
								
							} else if ((obj3.value < tempValuePrev && !(obj2.type == 'habit' && obj2.down == false)) || (obj2.type == 'habit' && obj2.up == false) ) {
								obj3.clickup = 0
								obj3.clickdown = 1

								obj2.challengeStats.countNegative += 1
								members[obj.id].challengeStats.countNegative += 1
								if (challengeTasks[challengeTaskIndex] != undefined) challengeTasks[challengeTaskIndex].challengeStats.countNegative += 1
								challenge.challengeStats.countNegative += 1
								obj2.challengeStats.streakNeg.current += 1						
								
								if (((obj2.challengeStats.streak.min == undefined) || (obj2.challengeStats.streak.min > obj2.challengeStats.streak.current)) && (obj2.challengeStats.streak.current != 0)) obj2.challengeStats.streak.min = obj2.challengeStats.streak.current  
								if (obj2.type != 'todo') if (((members[obj.id].challengeStats.streak.min == undefined) || (members[obj.id].challengeStats.streak.min > obj2.challengeStats.streak.current)) && (obj2.challengeStats.streak.current != 0)) members[obj.id].challengeStats.streak.min = obj2.challengeStats.streak.current  
								if (challengeTasks[challengeTaskIndex] != undefined) if (obj2.type != 'todo') if (((challengeTasks[challengeTaskIndex].challengeStats.streak.min == undefined) || (challengeTasks[challengeTaskIndex].challengeStats.streak.min > obj2.challengeStats.streak.current)) && (obj2.challengeStats.streak.current != 0)) challengeTasks[challengeTaskIndex].challengeStats.streak.min = obj2.challengeStats.streak.current  
								if ((obj2.challengeStats.streak.max == undefined) || (obj2.challengeStats.streak.max < obj2.challengeStats.streak.current)) obj2.challengeStats.streak.max = obj2.challengeStats.streak.current  
								if (obj2.type != 'todo') if ((members[obj.id].challengeStats.streak.max == undefined) || (members[obj.id].challengeStats.streak.max < obj2.challengeStats.streak.current)) members[obj.id].challengeStats.streak.max = obj2.challengeStats.streak.current  
								if (challengeTasks[challengeTaskIndex] != undefined) if (obj2.type != 'todo') if ((challengeTasks[challengeTaskIndex].challengeStats.streak.max == undefined) || (challengeTasks[challengeTaskIndex].challengeStats.streak.max < obj2.challengeStats.streak.current)) challengeTasks[challengeTaskIndex].challengeStats.streak.max = obj2.challengeStats.streak.current  

									
								obj2.challengeStats.streak.current = 0

								
							} else {	
								obj2.challengeStats.countNotDue +=1
								members[obj.id].challengeStats.countNotDue += 1
								if (challengeTasks[challengeTaskIndex] != undefined) challengeTasks[challengeTaskIndex].challengeStats.countNotDue += 1
								challenge.challengeStats.countNotDue += 1
							}
						}
						
						
						//Completion Streak
						obj2.challengeStats.count += obj3.total
						members[obj.id].challengeStats.count += obj3.total
						if (challengeTasks[challengeTaskIndex] != undefined) challengeTasks[challengeTaskIndex].challengeStats.count += obj3.total
						challenge.challengeStats.count += obj3.total
						
							
						//first & last Active
						if (obj2.challengeStats.first.utcTime > obj3.datePretty.utcTime || obj2.challengeStats.first.utcTime == myDateConverter(neverDate, 'utcTime') ) obj2.challengeStats.first = obj3.datePretty 
						if (members[obj.id].challengeStats.first.utcTime > obj3.datePretty.utcTime || members[obj.id].challengeStats.first.utcTime == myDateConverter(neverDate, 'utcTime') ) members[obj.id].challengeStats.first = obj3.datePretty 
						if (challengeTasks[challengeTaskIndex] != undefined) if (challengeTasks[challengeTaskIndex].challengeStats.first.utcTime > obj3.datePretty.utcTime || challengeTasks[challengeTaskIndex].challengeStats.first.utcTime == myDateConverter(neverDate, 'utcTime') ) challengeTasks[challengeTaskIndex].challengeStats.first = obj3.datePretty 
						if (obj2.challengeStats.last.utcTime < obj3.datePretty.utcTime) obj2.challengeStats.last = obj3.datePretty 
						if (members[obj.id].challengeStats.last.utcTime < obj3.datePretty.utcTime) members[obj.id].challengeStats.last = obj3.datePretty 
						if (challengeTasks[challengeTaskIndex] != undefined) if (challengeTasks[challengeTaskIndex].challengeStats.last.utcTime < obj3.datePretty.utcTime) challengeTasks[challengeTaskIndex].challengeStats.last = obj3.datePretty 
						
						//TimeDifference
						obj3.hourDiff = moment(obj3.datePretty.utcTime).diff(moment(tempDatePrev.utcTime), 'hours')
						if (obj2.challengeStats.timeDiffMin > obj3.hourDiff || firstRun == true) obj2.challengeStats.timeDiffMin = obj3.hourDiff
						if (obj2.challengeStats.timeDiffMax < obj3.hourDiff || firstRun == true) obj2.challengeStats.timeDiffMax = obj3.hourDiff
						
						if (members[obj.id].challengeStats.timeDiffMin.overall > obj3.hourDiff || members[obj.id].challengeStats.timeDiffMin.overall == undefined) members[obj.id].challengeStats.timeDiffMin.overall = obj3.hourDiff
						if (members[obj.id].challengeStats.timeDiffMin[obj2.type] > obj3.hourDiff || members[obj.id].challengeStats.timeDiffMin[obj2.type] == undefined) members[obj.id].challengeStats.timeDiffMin[obj2.type] = obj3.hourDiff
						if (members[obj.id].challengeStats.timeDiffMax.overall < obj3.hourDiff || members[obj.id].challengeStats.timeDiffMax.overall == undefined) members[obj.id].challengeStats.timeDiffMax.overall = obj3.hourDiff
						if (members[obj.id].challengeStats.timeDiffMax[obj2.type] < obj3.hourDiff || members[obj.id].challengeStats.timeDiffMax[obj2.type] == undefined) members[obj.id].challengeStats.timeDiffMax[obj2.type] = obj3.hourDiff
						
						if (challengeTasks[challengeTaskIndex] != undefined) if (challengeTasks[challengeTaskIndex].challengeStats.timeDiffMin.overall > obj3.hourDiff || challengeTasks[challengeTaskIndex].challengeStats.timeDiffMin.overall == undefined) challengeTasks[challengeTaskIndex].challengeStats.timeDiffMin.overall = obj3.hourDiff
						if (challengeTasks[challengeTaskIndex] != undefined) if (challengeTasks[challengeTaskIndex].challengeStats.timeDiffMin[obj2.type] > obj3.hourDiff || challengeTasks[challengeTaskIndex].challengeStats.timeDiffMin[obj2.type] == undefined) challengeTasks[challengeTaskIndex].challengeStats.timeDiffMin[obj2.type] = obj3.hourDiff
						if (challengeTasks[challengeTaskIndex] != undefined) if (challengeTasks[challengeTaskIndex].challengeStats.timeDiffMax.overall < obj3.hourDiff || challengeTasks[challengeTaskIndex].challengeStats.timeDiffMax.overall == undefined) challengeTasks[challengeTaskIndex].challengeStats.timeDiffMax.overall = obj3.hourDiff
						if (challengeTasks[challengeTaskIndex] != undefined) if (challengeTasks[challengeTaskIndex].challengeStats.timeDiffMax[obj2.type] < obj3.hourDiff || challengeTasks[challengeTaskIndex].challengeStats.timeDiffMax[obj2.type] == undefined) challengeTasks[challengeTaskIndex].challengeStats.timeDiffMax[obj2.type] = obj3.hourDiff
						


						
						//Value Difference
						obj3.valueDiff = Math.round((obj3.value - tempValuePrev)*1000)/1000
						if (obj2.challengeStats.valueDiffMin > obj3.valueDiff || firstRun == true) obj2.challengeStats.valueDiffMin = obj3.valueDiff
						if (obj2.challengeStats.valueDiffMax < obj3.valueDiff || firstRun == true) obj2.challengeStats.valueDiffMax = obj3.valueDiff

						if (members[obj.id].challengeStats.valueDiffMin.overall> obj3.valueDiff || members[obj.id].challengeStats.valueDiffMin.overall== undefined) members[obj.id].challengeStats.valueDiffMin.overall= obj3.valueDiff
						if (members[obj.id].challengeStats.valueDiffMin[obj2.type]> obj3.valueDiff || members[obj.id].challengeStats.valueDiffMin[obj2.type]== undefined) members[obj.id].challengeStats.valueDiffMin[obj2.type]= obj3.valueDiff
						if (members[obj.id].challengeStats.valueDiffMax.overall < obj3.valueDiff || members[obj.id].challengeStats.valueDiffMax.overall == undefined) members[obj.id].challengeStats.valueDiffMax.overall = obj3.valueDiff
						if (members[obj.id].challengeStats.valueDiffMax[obj2.type] < obj3.valueDiff || members[obj.id].challengeStats.valueDiffMax[obj2.type] == undefined) members[obj.id].challengeStats.valueDiffMax[obj2.type] = obj3.valueDiff

						if (challengeTasks[challengeTaskIndex] != undefined) if (challengeTasks[challengeTaskIndex].challengeStats.valueDiffMin.overall> obj3.valueDiff || challengeTasks[challengeTaskIndex].challengeStats.valueDiffMin.overall== undefined) challengeTasks[challengeTaskIndex].challengeStats.valueDiffMin.overall= obj3.valueDiff
						if (challengeTasks[challengeTaskIndex] != undefined) if (challengeTasks[challengeTaskIndex].challengeStats.valueDiffMin[obj2.type]> obj3.valueDiff || challengeTasks[challengeTaskIndex].challengeStats.valueDiffMin[obj2.type]== undefined) challengeTasks[challengeTaskIndex].challengeStats.valueDiffMin[obj2.type]= obj3.valueDiff
						if (challengeTasks[challengeTaskIndex] != undefined) if (challengeTasks[challengeTaskIndex].challengeStats.valueDiffMax.overall < obj3.valueDiff || challengeTasks[challengeTaskIndex].challengeStats.valueDiffMax.overall == undefined) challengeTasks[challengeTaskIndex].challengeStats.valueDiffMax.overall = obj3.valueDiff
						if (challengeTasks[challengeTaskIndex] != undefined) if (challengeTasks[challengeTaskIndex].challengeStats.valueDiffMax[obj2.type] < obj3.valueDiff || challengeTasks[challengeTaskIndex].challengeStats.valueDiffMax[obj2.type] == undefined) challengeTasks[challengeTaskIndex].challengeStats.valueDiffMax[obj2.type] = obj3.valueDiff
						
						addToArray = {};
						addToArray = {member: members[obj.id], task: obj2, taskHistory: obj3}
						membersTaskHistory.push(addToArray)
						
						//Reset Values
						tempValuePrev = obj3.value
						tempDatePrev = obj3.datePretty
						firstRun = false
					}); // history
					
					//Final Streaks
					if (((obj2.challengeStats.streak.min == undefined) || (obj2.challengeStats.streak.min > obj2.challengeStats.streak.current)) && (obj2.challengeStats.streak.current != 0)) obj2.challengeStats.streak.min = obj2.challengeStats.streak.current  
					if (obj2.type != 'todo') if (((members[obj.id].challengeStats.streak.min == undefined) || (members[obj.id].challengeStats.streak.min > obj2.challengeStats.streak.current)) && (obj2.challengeStats.streak.current != 0)) members[obj.id].challengeStats.streak.min = obj2.challengeStats.streak.current  
					if (challengeTasks[challengeTaskIndex] != undefined) if (obj2.type != 'todo') if (((challengeTasks[challengeTaskIndex].challengeStats.streak.min == undefined) || (challengeTasks[challengeTaskIndex].challengeStats.streak.min > obj2.challengeStats.streak.current)) && (obj2.challengeStats.streak.current != 0)) challengeTasks[challengeTaskIndex].challengeStats.streak.min = obj2.challengeStats.streak.current  
					if ((obj2.challengeStats.streak.max == undefined) || (obj2.challengeStats.streak.max < obj2.challengeStats.streak.current)) obj2.challengeStats.streak.max = obj2.challengeStats.streak.current  
					if (obj2.type != 'todo') if ((members[obj.id].challengeStats.streak.max == undefined) || (members[obj.id].challengeStats.streak.max < obj2.challengeStats.streak.current)) members[obj.id].challengeStats.streak.max = obj2.challengeStats.streak.current  
					if (challengeTasks[challengeTaskIndex] != undefined) if (obj2.type != 'todo') if ((challengeTasks[challengeTaskIndex].challengeStats.streak.max == undefined) || (challengeTasks[challengeTaskIndex].challengeStats.streak.max < obj2.challengeStats.streak.current)) challengeTasks[challengeTaskIndex].challengeStats.streak.max = obj2.challengeStats.streak.current  

					if (((obj2.challengeStats.streakNeg.min == undefined) || (obj2.challengeStats.streakNeg.min > obj2.challengeStats.streakNeg.current)) && (obj2.challengeStats.streakNeg.current != 0)) obj2.challengeStats.streakNeg.min = obj2.challengeStats.streakNeg.current  
					if (obj2.type != 'todo') if (((members[obj.id].challengeStats.streakNeg.min == undefined) || (members[obj.id].challengeStats.streakNeg.min > obj2.challengeStats.streakNeg.current)) && (obj2.challengeStats.streakNeg.current != 0)) members[obj.id].challengeStats.streakNeg.min = obj2.challengeStats.streakNeg.current  
					if (challengeTasks[challengeTaskIndex] != undefined) if (obj2.type != 'todo') if (((challengeTasks[challengeTaskIndex].challengeStats.streakNeg.min == undefined) || (challengeTasks[challengeTaskIndex].challengeStats.streakNeg.min > obj2.challengeStats.streakNeg.current)) && (obj2.challengeStats.streakNeg.current != 0)) challengeTasks[challengeTaskIndex].challengeStats.streakNeg.min = obj2.challengeStats.streakNeg.current  
					if ((obj2.challengeStats.streakNeg.max == undefined) || (obj2.challengeStats.streakNeg.max < obj2.challengeStats.streakNeg.current)) obj2.challengeStats.streakNeg.max = obj2.challengeStats.streakNeg.current  
					if (obj2.type != 'todo') if ((members[obj.id].challengeStats.streakNeg.max == undefined) || (members[obj.id].challengeStats.streakNeg.max < obj2.challengeStats.streakNeg.current)) members[obj.id].challengeStats.streakNeg.max = obj2.challengeStats.streakNeg.current  
					if (challengeTasks[challengeTaskIndex] != undefined) if (obj2.type != 'todo') if ((challengeTasks[challengeTaskIndex].challengeStats.streakNeg.max == undefined) || (challengeTasks[challengeTaskIndex].challengeStats.streakNeg.max < obj2.challengeStats.streakNeg.current)) challengeTasks[challengeTaskIndex].challengeStats.streakNeg.max = obj2.challengeStats.streakNeg.current  

					
								
					//Add completed to-do or completed daily
					addToArray = {};
					addToArray = {member: members[obj.id], task: obj2}
					membersTask.push(addToArray)
				});
				
				//Determine Activity
				if (groupId == 'party' && (members[obj.id].lastChat.occured.utcTime < members[obj.id].lastTransformation.occured.utcTime) && (members[obj.id].challengeStats.last.utcTime < members[obj.id].lastTransformation.occured.utcTime) && (members[obj.id].lastLoggedIn.utcTime < members[obj.id].lastTransformation.occured.utcTime) && (members[obj.id].lastDropItem.utcTime < members[obj.id].lastTransformation.occured.utcTime) && (members[obj.id].lastBuff.occured.utcTime < members[obj.id].lastTransformation.occured.utcTime)) {
					members[obj.id].lastActive = members[obj.id].lastTransformation.occured
				} else if (groupId == 'party' && (members[obj.id].lastChat.occured.utcTime < members[obj.id].lastBuff.occured.utcTime) && (members[obj.id].challengeStats.last.utcTime < members[obj.id].lastBuff.occured.utcTime) && (members[obj.id].lastLoggedIn.utcTime < members[obj.id].lastBuff.occured.utcTime) && (members[obj.id].lastDropItem.utcTime < members[obj.id].lastBuff.occured.utcTime)) {
					members[obj.id].lastActive = members[obj.id].lastBuff.occured
				} else if ((members[obj.id].lastChat.occured.utcTime < members[obj.id].lastDropItem.utcTime) && (members[obj.id].challengeStats.last.utcTime < members[obj.id].lastDropItem.utcTime) && (members[obj.id].lastLoggedIn.utcTime < members[obj.id].lastDropItem.utcTime)) {
					members[obj.id].lastActive = members[obj.id].lastDropItem
				} else if ((members[obj.id].lastChat.occured.utcTime < members[obj.id].lastLoggedIn.utcTime) && (members[obj.id].challengeStats.last.utcTime <  members[obj.id].lastLoggedIn.utcTime)){
					members[obj.id].lastActive = members[obj.id].lastLoggedIn
				} else if (members[obj.id].lastChat.occured.utcTime < members[obj.id].challengeStats.last.utcTime){
					members[obj.id].lastActive = members[obj.id].challengeStats.last
				} else {
					members[obj.id].lastActive = members[obj.id].lastChat.occured
				}
				
				if (moment().subtract(12, 'hours').isBefore(members[obj.id].lastActive.utcTime)) challenge.memberTotals.activeLess12Hr++
				if (moment().subtract(24, 'hours').isBefore(members[obj.id].lastActive.utcTime)) challenge.memberTotals.activeLess24Hr++
				if (moment().subtract(7, 'days').isBefore(members[obj.id].lastActive.utcTime)) challenge.memberTotals.activeLessWeek++
				if (moment().subtract(1, 'months').isBefore(members[obj.id].lastActive.utcTime)) challenge.memberTotals.activeLessMonth++
				
				if (members[obj.id].preferences.sleep == true){
					challenge.memberTotals.inInn++

					if (moment().subtract(12, 'hours').isBefore(members[obj.id].lastActive.utcTime)) challenge.memberTotals.inInn_activeLess12Hr++
					if (moment().subtract(24, 'hours').isBefore(members[obj.id].lastActive.utcTime)) challenge.memberTotals.inInn_activeLess24Hr++
					if (moment().subtract(7, 'days').isBefore(members[obj.id].lastActive.utcTime)) challenge.memberTotals.inInn_activeLessWeek++
					if (moment().subtract(1, 'months').isBefore(members[obj.id].lastActive.utcTime)) challenge.memberTotals.inInn_activeLessMonth++
				}


				//Challenge Activity 
				if (moment().subtract(12, 'hours').isBefore(members[obj.id].challengeStats.last.utcTime)) challenge.challengeStats.activeLess12Hr++
				if (moment().subtract(24, 'hours').isBefore(members[obj.id].challengeStats.last.utcTime)) challenge.challengeStats.activeLess24Hr++
				if (moment().subtract(7, 'days').isBefore(members[obj.id].challengeStats.last.utcTime)) challenge.challengeStats.activeLessWeek++
				if (moment().subtract(1, 'months').isBefore(members[obj.id].challengeStats.last.utcTime)) challenge.challengeStats.activeLessMonth++
				
				if (members[obj.id].preferences.sleep == true){
					challenge.challengeStats.inInn++

					if (moment().subtract(12, 'hours').isBefore(members[obj.id].challengeStats.last.utcTime)) challenge.challengeStats.inInn_activeLess12Hr++
					if (moment().subtract(24, 'hours').isBefore(members[obj.id].challengeStats.last.utcTime)) challenge.challengeStats.inInn_activeLess24Hr++
					if (moment().subtract(7, 'days').isBefore(members[obj.id].challengeStats.last.utcTime)) challenge.challengeStats.inInn_activeLessWeek++
					if (moment().subtract(1, 'months').isBefore(members[obj.id].challengeStats.last.utcTime)) challenge.challengeStats.inInn_activeLessMonth++
				}

				tempMembersList.push(obj.id)
			}); 
			if (debugShowObject) console.log(membersTaskHistory);
			if (debugShowObject) console.log(membersTask);
			if (debugShowObject) console.log(tempMembersList);
			
			//Member data format and collate
			
			///////////////////////////////////////////////////////////////
			////   members final loop  process no calcs    ////////////
			//////////////////////////////////////////////////////////////
			$.each(tempMembersList, function(index, obj){			
				$.each(sectionsToDisplay, function(index2, obj2){
					if (obj2.type == 'sectionTable' && (obj2.showOnly.includes('party') != true || groupId == 'party')) {
						if (sectionTables[obj2.id].type == 'member'){
							addToArray = []; //clear array
							$.each(sectionTables[obj2.id].dataTable, function(index3, obj3){
								addToArray.push(eval('members[obj].' + obj3))
							});
							sectionTables[obj2.id].dataSet.push(addToArray);
						}
					}
				});
			}); 

			///////////////////////////////////////////////////////////////
			////   members tasks 							   ////////////
			//////////////////////////////////////////////////////////////
			$.each(membersTask, function(index, obj){			
				$.each(sectionsToDisplay, function(index2, obj2){
					if (obj2.type == 'sectionTable' && (obj2.showOnly.includes('party') != true || groupId == 'party')) {
						if (sectionTables[obj2.id].type == 'membersTask'){
							addToArray = []; //clear array
							$.each(sectionTables[obj2.id].dataTable, function(index3, obj3){
								addToArray.push(eval('obj.' + obj3))
							});
							sectionTables[obj2.id].dataSet.push(addToArray);
						}
					}
				});
			});
			
			
			///////////////////////////////////////////////////////////////
			////   members task history					    ////////////
			//////////////////////////////////////////////////////////////
			$.each(membersTaskHistory, function(index, obj){			
				$.each(sectionsToDisplay, function(index2, obj2){
					if (obj2.type == 'sectionTable' && (obj2.showOnly.includes('party') != true || groupId == 'party')) {
						if (sectionTables[obj2.id].type == 'membersTaskHistory'){
							addToArray = []; //clear array
							$.each(sectionTables[obj2.id].dataTable, function(index3, obj3){
								addToArray.push(eval('obj.' + obj3))
							});
							sectionTables[obj2.id].dataSet.push(addToArray);
						}
					}
				});
			});
			if (debug) console.log('Finish collating memberListSet');

			///////////////////////////////////////////////////////////////
			////   Task Details				  				  ////////////
			//////////////////////////////////////////////////////////////
			$.each(challengeTasks, function(index, obj){			
				$.each(sectionsToDisplay, function(index2, obj2){
					if (obj2.type == 'sectionTable' && (obj2.showOnly.includes('party') != true || groupId == 'party')) {
						if (sectionTables[obj2.id].type == 'challengeTask'){
							addToArray = []; //clear array
							$.each(sectionTables[obj2.id].dataTable, function(index3, obj3){
								addToArray.push(eval('obj.' + obj3))
							});
							sectionTables[obj2.id].dataSet.push(addToArray);
						}
					}
				});
			});
			if (debug) console.log('Finish collating challengeTasks');

			
			///////////////////////////////////////////////////////////////
			////   chat likes (Chat was before)					    ////////////
			//////////////////////////////////////////////////////////////
			$.each(chatLikes, function(index, obj){
				//quick fix as member function done after
				if (members[obj.id] != undefined){
					obj.name = members[obj.id].profile.name
					obj.namePretty = '<a href="' + serverHabiticaProfile + obj.id + '" target="_blank">' + members[obj.id].profile.namePretty + '</a>'
					obj.nameNotPretty = '<a href="' + serverHabiticaProfile + obj.id + '" target="_blank">' + members[obj.id].profile.nameNotPretty + '</a>'
					obj.usernameNotPretty = '<a href="' + serverHabiticaProfile + obj.id + '" target="_blank">' + members[obj.id].profile.username + '</a>'
				} else {
					obj.name = notAvailableMember
					obj.namePretty = '<a href="' + serverHabiticaProfile + obj.id + '" target="_blank">' + notAvailableMember + '</a>'
					obj.nameNotPretty = '<a href="' + serverHabiticaProfile + obj.id + '" target="_blank">' + notAvailableMember + '</a>'
					obj.usernameNotPretty = '<a href="' + serverHabiticaProfile + obj.id + '" target="_blank">' + notAvailableMember + '</a>'
				}
				obj.usernamePretty = obj.usernameNotPretty
				
				$.each(sectionsToDisplay, function(index2, obj2){
					if (obj2.type == 'sectionTable' && (obj2.showOnly.includes('party') != true || groupId == 'party')) {
						if (sectionTables[obj2.id].type == 'chatLikes'){
							addToArray = []; //clear array
							$.each(sectionTables[obj2.id].dataTable, function(index3, obj3){
								addToArray.push(eval('obj.' + obj3))
							});
							sectionTables[obj2.id].dataSet.push(addToArray);
						}
					}
				});
			});
			if (debug) console.log('Finish chat Likes');

			///////////////////////////////////////////////////////////////
			////   PMs                                      ////////////
			//////////////////////////////////////////////////////////////
			$.each(user.inbox.messages, function(index, obj){
				if (tempMembersList.includes(obj.uuid)){
					modifyInboxProperties(obj);			
					
					$.each(sectionsToDisplay, function(index2, obj2){
						if (obj2.type == 'sectionTable' && (obj2.showOnly.includes('party') != true || groupId == 'party')) {
							if (sectionTables[obj2.id].type == 'inbox'){
								addToArray = []; //clear array
								$.each(sectionTables[obj2.id].dataTable, function(index3, obj3){
									addToArray.push(eval('obj.' + obj3))
								});
								//Don't include system messages if chatNotSystemExport
								sectionTables[obj2.id].dataSet.push(addToArray); 
							}
							
						}
					});
				}
			}); 
			if (debug) console.log('Finish collating PMs');
		};
		


		//////////////////////////////////////////////////////////////////////
		////   Formatting data for data sets     ///////////////////////////
		//////////////////////////////////////////////////////////////////////
	    function modifyChatProperties(obj) {
			obj.textPretty  = renderFormattedText(obj.text);
			if (obj.uuid == 'system') {
				obj.userPretty = 'System'
				obj.userNotPretty = 'System'
				obj.username = 'System'
				obj.usernameNotPretty = 'System'
				obj.usernamePretty = 'System'
				obj.userStylesPretty = ''
			} else {
				obj.userPretty = '<a href="' + serverHabiticaProfile + obj.uuid + '" target="_blank">' + renderFormattedText(obj.user) + '</a>';
				obj.userNotPretty = '<a href="' + serverHabiticaProfile + obj.uuid + '" target="_blank">' + renderFormattedText(obj.user, {removeParaTags: true}) + '</a>';
				if (obj.username == undefined) {
					obj.username = noUsernamePrefix + obj.user
					obj.usernameNotPretty = '<a href="' + serverHabiticaProfile + obj.uuid + '" target="_blank">' + noUsernamePrefix + obj.user + '</a>';
				} else {
					obj.usernameNotPretty = '<a href="' + serverHabiticaProfile + obj.uuid + '" target="_blank">' + obj.username + '</a>';
				}
				obj.usernamePretty = obj.usernameNotPretty
				
				if (obj.userStyles != undefined) {
					obj.userStylesPretty = JSON.stringify(obj.userStyles, null, ' ').replace(/: \{\n\s+/g, ': {').replace(/",\n\s+/g, ', ').replace(/"\n\s+\}/g, '}').replace(/(\r\n|\n|\r)/g,"<br />").replace(/"  "/g, '&nbsp;&nbsp');;
				} else {
					obj.userStylesPretty = ''
				}
			}

			obj.creation  = reformatDate(obj.timestamp);
			//if (debugShowObject) console.log(obj);
			if (obj.contributor  !=  undefined ) {
				if (obj.contributor.text  !=  undefined ) {
					obj.contribPretty = [];
					obj.contribPretty.text = obj.contributor.text;
					if (obj.contributor.level != undefined)	{
						obj.contribPretty.level = obj.contributor.level
					} else {
						obj.contribPretty.level = '';
					};
					if (obj.contributor.contributions  !=  undefined){
						obj.contribPretty.contributions = obj.contributor.contributions;
					} else {
						obj.contribPretty.contributions = '';
					}
					if (obj.contributor.admin === true) {
						obj.contribPretty.admin = true
					} else {
						obj.contribPretty.admin  = false
					}
				} else {
					obj.contribPretty = [];
					obj.contribPretty.text = '';
					obj.contribPretty.level = '';
					obj.contribPretty.contributions = '';
					obj.contribPretty.admin = false;
				}
			} else {
				obj.contribPretty = [];
				obj.contribPretty.text = '';
				obj.contribPretty.level = '';
				obj.contribPretty.contributions = '';
				obj.contribPretty.admin = false;
			}
		}
		
		function modifyInboxProperties(obj) {
			obj.textPretty  = renderFormattedText(obj.text, {'setParaClass':'chatText'});
			if (obj.uuid == 'system') {
				obj.userPretty = 'System'
				obj.userNotPretty = 'System'
				obj.username = 'System'
				obj.usernameNotPretty = 'System'
				obj.usernamePretty = 'System'
				obj.userStylesPretty = ''
			} else {
				obj.userPretty = '<a href="' + serverHabiticaProfile + obj.uuid + '" target="_blank">' + renderFormattedText(obj.user) + '</a>';
				obj.userNotPretty = '<a href="' + serverHabiticaProfile + obj.uuid + '" target="_blank">' + renderFormattedText(obj.user, {removeParaTags: true}) + '</a>';
				if (obj.username == undefined) {
					obj.username = noUsernamePrefix + obj.user
					obj.usernameNotPretty = '<a href="' + serverHabiticaProfile + obj.uuid + '" target="_blank">' + noUsernamePrefix + obj.user + '</a>';
				} else {
					obj.usernameNotPretty = '<a href="' + serverHabiticaProfile + obj.uuid + '" target="_blank">' + obj.username + '</a>';
				}
				obj.usernamePretty = obj.usernameNotPretty
				
				if (obj.userStyles != undefined) {
					obj.userStylesPretty = JSON.stringify(obj.userStyles, null, ' ').replace(/: \{\n\s+/g, ': {').replace(/",\n\s+/g, ', ').replace(/"\n\s+\}/g, '}').replace(/(\r\n|\n|\r)/g,"<br />").replace(/"  "/g, '&nbsp;&nbsp');;
				} else {
					obj.userStylesPretty = ''
				}
				
			}
			obj.creation  = reformatDate(obj.timestamp);
			//if (debugShowObject) console.log(obj);
			if (obj.contributor  !=  undefined ) {
				if (obj.contributor.text  !=  undefined ) {
					obj.contribPretty = [];
					obj.contribPretty.text = obj.contributor.text;
					if (obj.contributor.level != undefined)	{
						obj.contribPretty.level = obj.contributor.level
					} else {
						obj.contribPretty.level = '';
					};
					if (obj.contributor.contributions  !=  undefined){
						obj.contribPretty.contributions = obj.contributor.contributions;
					} else {
						obj.contribPretty.contributions = '';
					}
					if (obj.contributor.admin === true) {
						obj.contribPretty.admin = true
					} else {
						obj.contribPretty.admin  = false
					}
				} else {
					obj.contribPretty = [];
					obj.contribPretty.text = '';
					obj.contribPretty.level = '';
					obj.contribPretty.contributions = '';
					obj.contribPretty.admin = false;
				}
			} else {
				obj.contribPretty = [];
				obj.contribPretty.text = '';
				obj.contribPretty.level = '';
				obj.contribPretty.contributions = '';
				obj.contribPretty.admin = false;
			}
			if (obj.sent === true) {
				obj.sentPretty = 'true'
			} else {
				obj.sentPretty = 'false'
			}
		}
		
		function modifyUserProperties(obj) {
			if (obj.profile !=  undefined ){
				if (obj.profile.blurb  !=  undefined ) {
					obj.blurbPretty  = renderFormattedText(obj.profile.blurb)
				} else
				{
					obj.blurbPretty  = ''
				}
			} else
			{
				obj.blurbPretty  = ''
			};
			if (obj.id == 'system') {
				obj.profile.namePretty = 'System'
				obj.profile.nameNotPretty = 'System'
				obj.profile.username = 'System'
				obj.profile.usernameNotPretty = 'System'
				obj.profile.usernamePretty = 'System'
				obj.profile.avatar = ''
			} else {
				obj.profile.namePretty = '<a href="' + serverHabiticaProfile + obj.id + '" target="_blank">' + renderFormattedText(obj.profile.name) + '</a>';
				obj.profile.nameNotPretty = '<a href="' + serverHabiticaProfile + obj.id + '" target="_blank">' + renderFormattedText(obj.profile.name, {removeParaTags: true}) + '</a>';
				if (obj.auth != undefined && obj.auth.local != undefined && obj.auth.local.username != undefined) {
					obj.profile.username = obj.auth.local.username
					obj.profile.usernameNotPretty = '<a href="' + serverHabiticaProfile + obj.id + '" target="_blank">' + obj.auth.local.username + '</a>'
				} else {
					obj.profile.username = noUsernamePrefix + obj.profile.nameNotPretty 
					obj.profile.usernameNotPretty = '<a href="' + serverHabiticaProfile + obj.id + '" target="_blank">' + noUsernamePrefix + obj.profile.nameNotPretty + '</a>'
				}
				obj.profile.usernamePretty = obj.profile.usernameNotPretty 
				obj.profile.avatar = createAvatar(obj);
			}
			
			if (obj.stats.class == 'wizard')  {
				obj.stats.classPretty = 'mage'
			} else {
				obj.stats.classPretty = obj.stats.class
			}
			obj.inbox.canPM = !obj.inbox.optOut;
			obj.creation  = reformatDate(obj.auth.timestamps.created);
			var nextBirthday = moment({
											year: moment().year(),
											month: moment(obj.auth.timestamps.created).month(),
											day: moment(obj.auth.timestamps.created).date(),
											hour: moment(obj.auth.timestamps.created).hour(),
											minute: moment(obj.auth.timestamps.created).minute(),
											second: moment(obj.auth.timestamps.created).second()
										})
			if (moment() > nextBirthday) nextBirthday = moment({
											year: moment().year()+1,
											month: moment(obj.auth.timestamps.created).month(),
											day: moment(obj.auth.timestamps.created).date(),
											hour: moment(obj.auth.timestamps.created).hour(),
											minute: moment(obj.auth.timestamps.created).minute(),
											second: moment(obj.auth.timestamps.created).second()
										})
			
			obj.creation.nextBirthday =  reformatDate(nextBirthday)
			
			
			obj.lastLoggedIn  = reformatDate(obj.auth.timestamps.loggedin);
			obj.lastDropItem  = reformatDate(obj.items.lastDrop.date);
			//if (debugShowObject) console.log(obj);
			if (obj.contributor  !=  undefined ) {
				if (obj.contributor.text  !=  undefined ) {
					obj.contribPretty = [];
					obj.contribPretty.text = obj.contributor.text;
					if (obj.contributor.level != undefined)	{
						obj.contribPretty.level = obj.contributor.level
					} else {
						obj.contribPretty.level = '';
					};
					if (obj.contributor.contributions  !=  undefined){
						obj.contribPretty.contributions = obj.contributor.contributions;
					} else {
						obj.contribPretty.contributions = '';
					}
					if (obj.contributor.admin === true) {
						obj.contribPretty.admin = true
					} else {
						obj.contribPretty.admin  = false
					}
				} else {
					obj.contribPretty = [];
					obj.contribPretty.text = '';
					obj.contribPretty.level = '';
					obj.contribPretty.contributions = '';
					obj.contribPretty.admin = false;
				}
			} else {
				obj.contribPretty = [];
				obj.contribPretty.text = '';
				obj.contribPretty.level = '';
				obj.contribPretty.contributions = '';
				obj.contribPretty.admin = false;
			}
			
			//Round to 2 decimal places
			obj.stats.hpPretty = Math.round( obj.stats.hp * 100)/100;
			obj.stats.mpPretty = Math.round( obj.stats.mp * 100)/100;
			obj.stats.maxMPPretty = Math.round( obj.stats.maxMP * 100)/100;
			obj.stats.gpPretty = Math.round( obj.stats.gp * 100)/100;
			obj.stats.expPretty = Math.round( obj.stats.exp * 100)/100; 
			obj.stats.toNextLevelPretty = Math.round( obj.stats.toNextLevel * 100)/100;
			obj.stats.percentageMP = Math.round((obj.stats.mp / (obj.stats.maxMP) * 100) * 100)/100;
		}

		function modifyTaskProperties(obj) {
			obj.textPretty = renderFormattedText(obj.text)
			obj.textNotPretty = renderFormattedText(obj.text, {removeParaTags: true})

			obj.notesPretty = renderFormattedText(obj.notes, {setParaClass:'taskNotes'})
			obj.challenge.details = challengeTasks[obj.challenge.taskId]

			obj.creation  = reformatDate(obj.createdAt);
			obj.lastUpdated  = reformatDate(obj.updatedAt);		
			
			//Round to 2 decimal places
			obj.valuePretty = Math.round( obj.value * 1000)/1000;
		}
		
		function modifyTaskHistoryProperties(obj) {
		
			obj.datePretty  = reformatDate(obj.date);		
			
			//Round to 2 decimal places
			obj.valuePretty = Math.round( obj.value * 1000)/1000;
		}



		function reformatDate(dateString) {
				var formattedDate = myDateConverter(dateString, 'long');
				var shortDate     = myDateConverter(dateString, 'short');
				var relativeTime  = myDateConverter(dateString, 'relativeTime');
				var utcTime  = myDateConverter(dateString, 'utcTime');
				return { 'dateAndTime': formattedDate,
						 'shortDate': shortDate,
						 'relativeTime': relativeTime,
						 'utcTime': utcTime
				};
		}
		
		function createAvatar (user) {
			if (hideAvatar == false) {

				var wrapper = document.createElement('div');
				
				wrapper.appendChild(window.habiticaAvatar({user: user}));
				
				return wrapper.innerHTML;
			}
		}
		
		//////////////////////////////////////////////////////////////////////
		////   Sections 										   ////////////
		//////////////////////////////////////////////////////////////////////
		//Custom Section functions here.
		//With Events in the section after
		function formatOverviewSection(sectionId, title){
			var html = ''
			var htmlTOC = ''
			var htmlTOCDetail = ''
			var htmlReturnTOC = '<p><a href="#' + 'toc_' + sectionId + '" target="_self">Return To Section Table of Contents</a></p><hr/>'
			var subSectionTitle = ''
			var subSectionId = ''

			subSectionId = 'SummaryAndCategories'
			subSectionTitle = 'Summary, Categories and Owner'
			htmlTOCDetail += '<li><a href="#' + 'toc_' + subSectionId + '_' + sectionId  + '" target="_self">' + subSectionTitle + '</a></li>'
			html += '<h3 id="' + 'toc_' + subSectionId + '_' + sectionId +'">' + subSectionTitle + '</h3>'		
			html += '<p><span class="highlight">Owner:</span> ' + challenge.leader.profile.usernameNotPretty + ' (UserId: ' + challenge.leader.id + '   Display Name: ' + challenge.leader.profile.nameNotPretty +')'
			html += '<p><span class="highlight">Categories:</span> '
			if (challenge.categories.length > 0 ) {
				$.each(challenge.categories, function(index, obj){
					html += toTitleCase((obj.name.replace(/_/g, ' '))) + '&nbsp;&nbsp;&nbsp;&nbsp;' 
				})
			} else {
				html += 'None'
			}
			if (challenge.summary != undefined) html += '<p><span class="highlight">Summary:</span> ' + renderFormattedText(challenge.summary) + '</p>'				
			html += htmlReturnTOC		
			
			if (challenge.description != undefined) {
				subSectionId = 'ChallengeDescription'
				subSectionTitle = 'Challenge Description'
				htmlTOCDetail += '<li><a href="#' + 'toc_' + subSectionId + '_' + sectionId  + '" target="_self">' + subSectionTitle + '</a></li>'
				html += '<h3 id="' + 'toc_' + subSectionId + '_' + sectionId +'">' + subSectionTitle + '</h3>'
				html += '<p>' + renderFormattedText(challenge.description) + '</p>'
				html += htmlReturnTOC
			}
			
			subSectionId = 'TaskBreakdown'
			subSectionTitle = 'Task Breakdown'
			htmlTOCDetail += '<li><a href="#' + 'toc_' + subSectionId + '_' + sectionId  + '" target="_self">' + subSectionTitle + '</a></li>'
			html += '<h3 id="' + 'toc_' + subSectionId + '_' + sectionId +'">' + subSectionTitle + '</h3>'			

			html += '<p><table class=overview_memberActivity>' +
						'<tr><th>Habit</th><th>Daily</th><th>To-Do</th><th>Reward</th><th>Total</th></tr>' +
						'<tr><td>' + challenge.taskTotals.habit + '</td><td>' + challenge.taskTotals.daily + '</td><td>' + challenge.taskTotals.todo + '</td><td>' + challenge.taskTotals.reward + '</td><td>' + challenge.taskTotals.overall + '</td></tr>' +
					'</table></p> ' 
			html += htmlReturnTOC
			
			subSectionId = 'MemberBreakdown'
			subSectionTitle = 'Participant Breakdown'
			htmlTOCDetail += '<li><a href="#' + 'toc_' + subSectionId + '_' + sectionId  + '" target="_self">' + subSectionTitle + '</a></li>'
			html += '<h3 id="' + 'toc_' + subSectionId + '_' + sectionId +'">' + subSectionTitle + '</h3>'			
			html += '<p>Challenge Participants: ' +  challenge.memberTotals.fetchCount + '&nbsp;&nbsp;'
			if (groupId == 'party') {
				html +=  'Party' 
			} else {
				html += 'Guild'
			}
			html += ' Members: ' + group.memberCount + '</p>'
			html += '<p><table class=overview_classBreakdown>' + 
						'<tr><th>Warrior</th><th>Mage</th><th>Rogue</th><th>Healer</th></tr>' + 
						'<tr><td>' + challenge.memberTotals.class.warrior + '</td><td>' + challenge.memberTotals.class.wizard + '</td><td>' + challenge.memberTotals.class.rogue + '</td><td>' + challenge.memberTotals.class.healer + '</td></tr>' +
						'</table> ' + 
						'There are ' + challenge.memberTotals.underLevel10 + ' members under level 10 who might not have chosen their class yet.</p>'
			html += htmlReturnTOC
			
			subSectionId = 'MemberActivity'
			subSectionTitle = 'Participant Activity'
			htmlTOCDetail += '<li><a href="#' + 'toc_' + subSectionId + '_' + sectionId  + '" target="_self">' + subSectionTitle + '</a></li>'
			html += '<h3 id="' + 'toc_' + subSectionId + '_' + sectionId +'">' + subSectionTitle + '</h3>'			
			html += '<p>Challenge Participants: ' +  challenge.memberTotals.fetchCount + '&nbsp;&nbsp;Total '
			
			html += '<p><table class=overview_memberActivity><caption>Participant Challenge Activity Only</caption> ' +
						'<tr><th></th><th>Active < 12 hr</th><th>Active 12 hr < 24 hr</th><th>Active 24 hr < 1 wk</th><th>Active 1 wk < 1 mth</th><th>Active > 1 month</th></tr>' +
						'<tr><th>Overall</th><td>' + challenge.challengeStats.activeLess12Hr + '</td><td>' + (challenge.challengeStats.activeLess24Hr - challenge.challengeStats.activeLess12Hr) + '</td><td>' + (challenge.challengeStats.activeLessWeek - challenge.challengeStats.activeLess24Hr) + '</td><td>' + (challenge.challengeStats.activeLessMonth - challenge.challengeStats.activeLessWeek) + '</td><td>' + (challenge.memberTotals.fetchCount - challenge.challengeStats.activeLessMonth) + '</td></tr>' +
						'<tr><th>Active</th><td>' + (challenge.challengeStats.activeLess12Hr - challenge.challengeStats.inInn_activeLess12Hr) + '</td><td>' + (challenge.challengeStats.activeLess24Hr - challenge.challengeStats.activeLess12Hr - (challenge.challengeStats.inInn_activeLess24Hr - challenge.challengeStats.inInn_activeLess12Hr)) + '</td><td>' + (challenge.challengeStats.activeLessWeek - challenge.challengeStats.activeLess24Hr - (challenge.challengeStats.inInn_activeLessWeek - challenge.challengeStats.inInn_activeLess24Hr)) + '</td><td>' + (challenge.challengeStats.activeLessMonth - challenge.challengeStats.activeLessWeek - (challenge.challengeStats.inInn_activeLessMonth - challenge.challengeStats.inInn_activeLessWeek)) + '</td><td>' + (challenge.memberTotals.fetchCount - challenge.challengeStats.activeLessMonth - (challenge.memberTotals.inInn - challenge.challengeStats.inInn_activeLessMonth)) + '</td></tr>' +
						'<tr><th>In Inn</th><td>' + challenge.challengeStats.inInn_activeLess12Hr + '</td><td>' + (challenge.challengeStats.inInn_activeLess24Hr - challenge.challengeStats.inInn_activeLess12Hr) + '</td><td>' + (challenge.challengeStats.inInn_activeLessWeek - challenge.challengeStats.inInn_activeLess24Hr) + '</td><td>' + (challenge.challengeStats.inInn_activeLessMonth - challenge.challengeStats.inInn_activeLessWeek) + '</td><td>' + (challenge.memberTotals.inInn - challenge.challengeStats.inInn_activeLessMonth) + '</td></tr>' +
					'</table></p> ' 

			html += '<p><table class=overview_memberActivity><caption>All Participant Activity</caption> ' +
						'<tr><th></th><th>Active < 12 hr</th><th>Active 12 hr < 24 hr</th><th>Active 24 hr < 1 wk</th><th>Active 1 wk < 1 mth</th><th>Active > 1 month</th></tr>' +
						'<tr><th>Overall</th><td>' + challenge.memberTotals.activeLess12Hr + '</td><td>' + (challenge.memberTotals.activeLess24Hr - challenge.memberTotals.activeLess12Hr) + '</td><td>' + (challenge.memberTotals.activeLessWeek - challenge.memberTotals.activeLess24Hr) + '</td><td>' + (challenge.memberTotals.activeLessMonth - challenge.memberTotals.activeLessWeek) + '</td><td>' + (challenge.memberTotals.fetchCount - challenge.memberTotals.activeLessMonth) + '</td></tr>' +
						'<tr><th>Active</th><td>' + (challenge.memberTotals.activeLess12Hr - challenge.memberTotals.inInn_activeLess12Hr) + '</td><td>' + (challenge.memberTotals.activeLess24Hr - challenge.memberTotals.activeLess12Hr - (challenge.memberTotals.inInn_activeLess24Hr - challenge.memberTotals.inInn_activeLess12Hr)) + '</td><td>' + (challenge.memberTotals.activeLessWeek - challenge.memberTotals.activeLess24Hr - (challenge.memberTotals.inInn_activeLessWeek - challenge.memberTotals.inInn_activeLess24Hr)) + '</td><td>' + (challenge.memberTotals.activeLessMonth - challenge.memberTotals.activeLessWeek - (challenge.memberTotals.inInn_activeLessMonth - challenge.memberTotals.inInn_activeLessWeek)) + '</td><td>' + (challenge.memberTotals.fetchCount - challenge.memberTotals.activeLessMonth - (challenge.memberTotals.inInn - challenge.memberTotals.inInn_activeLessMonth)) + '</td></tr>' +
						'<tr><th>In Inn</th><td>' + challenge.memberTotals.inInn_activeLess12Hr + '</td><td>' + (challenge.memberTotals.inInn_activeLess24Hr - challenge.memberTotals.inInn_activeLess12Hr) + '</td><td>' + (challenge.memberTotals.inInn_activeLessWeek - challenge.memberTotals.inInn_activeLess24Hr) + '</td><td>' + (challenge.memberTotals.inInn_activeLessMonth - challenge.memberTotals.inInn_activeLessWeek) + '</td><td>' + (challenge.memberTotals.inInn - challenge.memberTotals.inInn_activeLessMonth) + '</td></tr>' +
					'</table></p> ' 
			html += htmlReturnTOC


			//Guild Details
			subSectionId = 'GroupDetails'
			if (groupId == 'party') {
				subSectionTitle =  'Party' 
			} else {
				subSectionTitle = 'Guild'
			}
			subSectionTitle += ': ' + group.nameNotPretty
			if (challenge.group.name != group.name) subSectionTitle += ' (Located : ' + challenge.group.nameNotPretty + ')' 
			htmlTOCDetail += '<li><a href="#' + 'toc_' + subSectionId + '_' + sectionId  + '" target="_self">' + subSectionTitle + '</a></li>'
			html += '<h3 id="' + 'toc_' + subSectionId + '_' + sectionId +'">' + subSectionTitle + '</h3>'			
			
			html += '<h3>Categories</h3><ul>'
			if (group.categories.length > 0 ) {
				$.each(group.categories, function(index, obj){
					html += '<li>' + toTitleCase((obj.name.replace(/_/g, ' '))) + '</li>'
				})
			} else {
				html += 'None'
			}
			html += '</ul>'
			if (group.summary != undefined) html += '<h3>Summary</h3><p> ' + renderFormattedText(group.summary) + '</p>'				
			if (group.description != undefined) html += '<h3>Description</h3><p>' + renderFormattedText(group.description) + '</p>'
			html += '<h3>Leader</h3><p>' + group.leader.profile.nameNotPretty + ' (UserId: ' + group.leader.id + ')' //+ ' (Last Active: ' + members[group.leader.id].lastActive.relativeTime + ') </p>'
			html += htmlReturnTOC
/*			
			//Chat
			subSectionId = 'ChatBreakdown'
			subSectionTitle = 'Chat Breakdown'
			htmlTOCDetail += '<li><a href="#' + 'toc_' + subSectionId + '_' + sectionId  + '" target="_self">' + subSectionTitle + '</a></li>'
			html += '<h3 id="' + 'toc_' + subSectionId + '_' + sectionId +'">' + subSectionTitle + '</h3>'			
			if (group.chat.length > 0) {
				var chatDayPeriod = (Math.round((moment(group.chatTotals.lastChat.utcTime).diff(moment(group.chatTotals.firstChat.utcTime), 'hours'))/24*100)/100) 
				var displayTimePeriod = []
				var displayTimePeriod_notSystem = []
				var displayTimePeriod_system = []
				if (chatDayPeriod < 5){
					//set time into minutes
					timeDivision = (60 * 1000)
					timeDivisonName = ' min'
				} else if (chatDayPeriod < 20) {
					//set time into hours
					timeDivision = (60 * 60 * 100)
					timeDivisonName = ' hr'
				} else {
					//set time into days
					timeDivision = (60 * 60 * 24 * 1000)
					timeDivisonName = ' day'
				}
				//update arrays
				$.each(group.chatTotals.timePeriod, function(index, obj){
					displayTimePeriod.push(Math.round(obj / timeDivision))
				});
				$.each(group.chatTotals.timePeriod_notSystem, function(index, obj){
					displayTimePeriod_notSystem.push(Math.round(obj / timeDivision))
				});
				$.each(group.chatTotals.timePeriod_system, function(index, obj){
					displayTimePeriod_system.push(Math.round(obj / timeDivision))
				});
				
				if (debugShowObject) console.log(displayTimePeriod)
				
				html += '<p>Chat period: ' + group.chatTotals.firstChat.dateAndTime + ' to ' + group.chatTotals.lastChat.dateAndTime + ' (' + chatDayPeriod + ' days)</p>'
				html += '<p><table class=overview_chatActivity><caption>Chat anaylsis of time between messages</caption>' + 
						'<tr><th></th><th>No Of Lines</th><th>Mean</th><th>Median</th><th>Mode</th><th>Min Time Diff</th><th>Max Time Diff</th></tr>' 
				if (displayTimePeriod.length > 0) {		
					html += '<tr><th>Overall</th><td>' + group.chat.length + '</td><td>' + (Math.round(mean(displayTimePeriod)*100)/100) + timeDivisonName + '</td><td>' + (Math.round(median(displayTimePeriod)*100)/100) + timeDivisonName + '</td><td>' + (Math.round(mode(displayTimePeriod)*100)/100) + timeDivisonName + '</td><td>' + smallest(displayTimePeriod) + timeDivisonName + '</td><td>' + largest(displayTimePeriod) + timeDivisonName + '</td>' 
				} else {
						html += '<tr><th>Overall</th><td>' + group.chat.length + '</td><td>' + '-N/A-' + '</td><td>' + '-N/A-' + '</td><td>' + '-N/A-' + '</td><td>' + '-N/A-' + '</td>' 
				}
				if (groupId == 'party') {
					if (displayTimePeriod_notSystem.length > 0) {
						html += '<tr><th>Member</th><td>' + group.chatTotals.count_notSystem + '</td><td>' + (Math.round(mean(displayTimePeriod_notSystem)*100)/100) + timeDivisonName + '</td><td>' + (Math.round(median(displayTimePeriod_notSystem)*100)/100) + timeDivisonName + '</td><td>' + (Math.round(mode(displayTimePeriod_notSystem)*100)/100) + timeDivisonName + '</td><td>' + smallest(displayTimePeriod_notSystem) + timeDivisonName + '</td><td>' + largest(displayTimePeriod_notSystem) + timeDivisonName +  '</td>' 
					} else {
						html += '<tr><th>Member</th><td>' + group.chatTotals.count_notSystem + '</td><td>' + '-N/A-' + '</td><td>' + '-N/A-' + '</td><td>' + '-N/A-' + '</td><td>' + '-N/A-' + '</td>' 
					}
					if (displayTimePeriod_system.length > 0) {
						html += '<tr><th>System</th><td>' + group.chatTotals.count_system + '</td><td>' + (Math.round(mean(displayTimePeriod_system)*100)/100) + timeDivisonName + '</td><td>' + (Math.round(median(displayTimePeriod_system)*100)/100) + timeDivisonName + '</td><td>' + (Math.round(mode(displayTimePeriod_system)*100)/100) + timeDivisonName + '</td><td>' + smallest(displayTimePeriod_system) + timeDivisonName + '</td><td>' + largest(displayTimePeriod_system) + timeDivisonName +  '</td>' 
					} else {
						html += '<tr><th>System</th><td>' + group.chatTotals.count_system + '</td><td>' + '-N/A-' + '</td><td>' + '-N/A-' + '</td><td>' + '-N/A-' + '</td><td>' + '-N/A-' + '</td>' 
					}
				}
				html += '</table></p> '
			} else
			{
				html +=  '<p>It appears a vow of silence has been taken, as there is no chat to report on.</p>'
			}
			html += htmlReturnTOC
*/			

			htmlTOC += '<nav role="navigation" class="table-of-contents">'
			htmlTOC += '<h3 id="' + 'toc_' + sectionId + '">Table Of Contents</h3>'
			htmlTOC += '<ul>'
			htmlTOC += htmlTOCDetail
			htmlTOC += '</ul></nav>'
			htmlTOC += '<hr/>'

			html = htmlTOC + html
			
			//Finally just return the data!
			if (! html) {
				return;
			} 
			var id    = sectionId + 'Section';
			var orderId = sectionId;
			var refreshId = sectionId + SECTIONREFRESH 
			html = '<span id="' + refreshId + '">' + html + '</span>'		
			TOC[orderId] = {'target': id, 'title':  title};
			MAIN[orderId] = {'id': id, 'title': title, 'refreshHtml': html, 'refreshId': refreshId, 'longContent': true,
				'html': html};
		}

		function formatPerMemberStatsSection(sectionId, title){
			var html = ''
			var id    = sectionId + 'Section';
			var orderId = sectionId;
			var refreshId = sectionId + SECTIONREFRESH 
			var refreshHtml = ''
			
			var htmlSelection = ''
			var htmlTOC = ''
			var htmlTableData = []
			var htmlTablePre = ''
			var htmlTablePost = ''
			var htmlTablePreTOC = ''
			var htmlTablePostTOC = ''
			var subSectionTitle = ''
			var subSectionId = ''
			var htmlReturnTOC = '<a href="#' + 'toc_' + sectionId + '" target="_self">Return To Section Table of Contents</a>'
			var rndInt
			
			if (challenge.memberCount > 0) {
				//handle no members of challenge
				if ((memberIdSelection == undefined) || (newFetch)) {
					rndInt = getRandomInt(0, memberListToFetch.length - 1)
					memberIdSelection = memberListToFetch[rndInt].id
				}
				if (debugShowObject) console.log(memberIdSelection);
				
				
				
				//Determine the HTML Data
				var htmlTableData = formatSubTableData(sectionId, memberIdSelection, htmlReturnTOC)
				if (debugShowObject) console.log(htmlTableData); 
				
				///////////////////////////////////////////////////////////////
				////   Selection Section                               ///////
				//////////////////////////////////////////////////////////////
				if (debug) console.log('Start combo list for Per Stat Member');
				htmlSelection += '<select class="div-togglePerMemberStats" id="togglePerMemberStats"  data-target=".showPerMemberStats">'
				
				$.each(memberListToFetch, function(index, obj){	
					htmlSelection += '<option value="' + obj.id + '"'
					if (obj.id == memberIdSelection) htmlSelection += ' selected '
					htmlSelection += '>' + index + '. ' + members[obj.id].profile.nameNotPretty + '</option>';
				});		
						
				htmlSelection += '</select>'
				htmlSelection +=  '<input class="div-perMemberStats_pickRandomMember" id="perMemberStats_pickRandomMember" type="submit" value="Pick a Random Member" />' 
				
				if (debug) console.log('Finish combo list for Per Stat Member');

				
				htmlTablePre += '<h2 class="div-"selectedItem_' + sectionId + '">' + members[memberIdSelection].profile.nameNotPretty 
				if ((userId == challenge.leader.id) || (userIsAdmin)) {
					htmlTablePre +=  '<input class="div-perMemberStats_awardChallenge" id="perMemberStats_awardChallenge" type="submit" value="Award Challenge" />'
					htmlTablePre +=  '<input class="div-perMemberStats_giftGem" id="perMemberStats_giftGem" type="submit" value="Gift Gems" />'
					htmlTablePre +=  '<input class="div-perMemberStats_messageUser" id="perMemberStats_messageUser" type="submit" value="Message User" />'
				}
				htmlTablePre += '</h2>'
				
				///////////////////////////////////////////////////////////////
				////   Profile Section                                 ///////
				//////////////////////////////////////////////////////////////
				subSectionId = 'MemberDetails'
				subSectionTitle = 'Participant Details'
				htmlTablePreTOC += '<li><a href="#' + 'toc_' + subSectionId + '_' + sectionId  + '" target="_self">' + subSectionTitle + '</a></li>'
				htmlTablePre += '<hr class="padded" />'
				htmlTablePre += '<h3 id="' + 'toc_' + subSectionId + '_' + sectionId +'">' + subSectionTitle + '</h3>'
				htmlTablePre += '<table class="perMemberStats_participantDetails" id="perMemberStats_participantDetails">'
				htmlTablePre += '<tr><th>Name: </th><td>' + members[memberIdSelection].profile.usernameNotPretty + ' (User Id: ' + memberIdSelection + ')</td></tr>'
				htmlTablePre += '<tr><th>Display Name: </th><td>' + members[memberIdSelection].profile.nameNotPretty + '</td></tr>'
				htmlTablePre += '<tr><th>Born: </th><td>' + members[memberIdSelection].creation.dateAndTime + '</td></tr>'
				htmlTablePre += '<tr><th>Joined Challenge: </th><td>' + members[memberIdSelection].challengeStats.joined.dateAndTime + '</td></tr>'
				htmlTablePre += '<tr><th>Last Active In Challenge: </th><td>' + members[memberIdSelection].challengeStats.last.dateAndTime + '</td></tr>'
				htmlTablePre += '<tr><th>Last Active: </th><td>' + members[memberIdSelection].lastActive.dateAndTime 
				if (members[memberIdSelection].preferences.sleep) htmlTablePre +=  ' (Currently resting in the Inn)'
				htmlTablePre += '</td></tr>'
				htmlTablePre += '<tr><th>Last Cron: </th><td>' + members[memberIdSelection].lastLoggedIn.dateAndTime + '</td></tr>'
				htmlTablePre += '<tr><th>Level & Class: </th><td>Level ' + members[memberIdSelection].stats.lvl + ' ' + members[memberIdSelection].stats.classPretty + '</td></tr>'
				htmlTablePre += '</table>'
				htmlTablePre += '<p class="subheading">Profile: <br />' + members[memberIdSelection].blurbPretty + '</p>'
				htmlTablePre += htmlReturnTOC 


				htmlTOC += '<nav role="navigation" class="table-of-contents">'
				htmlTOC += '<h3 id="' + 'toc_' + sectionId + '">Table Of Contents</h3>'
				htmlTOC += '<ul>'
				htmlTOC += htmlTablePreTOC
				htmlTOC += htmlTableData[1]
				htmlTOC += htmlTablePostTOC
				htmlTOC += '</ul></nav>'
				htmlTOC += '<hr/>'

				if (debug) console.log('The final flourish Calc for Per Stat Member');
	
			} else {
				htmlTablePre = 'No Participants in challenge'
				
				//Determine the HTML Data -- Need to generate so it does not error.
				var htmlTableData = formatSubTableData(sectionId, memberIdSelection, htmlReturnTOC)
				if (debugShowObject) console.log(htmlTableData); 
			}
			//Finally just return the data!
			if (!(htmlSelection + htmlTOC + htmlTablePre + htmlTableData[0])) {
				return;
			} 
			html = '<span id="' + refreshId + '">' + htmlSelection + htmlTOC + htmlTablePre + '</span>'	+ htmlTableData[0] 	
			refreshHtml = htmlSelection + htmlTOC + htmlTablePre

			
			TOC[orderId] = {'target': id, 'title':  title};
			MAIN[orderId] = {'id': id, 'title': title, 'refreshHtml': refreshHtml, 'refreshId': refreshId, 'longContent': true,
				'html': html, 
				'function': constructTable_reproduce, 
				'functionPar': [sectionId]
			};
			
		}
		
		///////////////////////////////////////////////////////////////////////
		////   Custom events  for custom Sections above             //////////
		/////////////////////////////////////////////////////////////////////
		$(document).unbind('click'); //remove random elements listeners
		$(document).unbind('change'); //remove random elements listeners
		
		$(document).on('change', '.div-togglePerMemberStats', function(event){
			var assocSectionId = 'perMemberStats'
			if (debug) console.log('debug #showPerMemberStats (Change)');
			newFetch = false
			memberIdSelection   = $(this).val()
			if (debugShowObject) console.log(memberIdSelection);
			
			$.each(sectionsToDisplay, function(index, obj){
				if (obj.id == assocSectionId) {
					formatPerMemberStatsSection(obj.id, obj.title)
					refreshAndDisplayMAIN([obj.id]);
				}
			});
			if (debug) console.log('finish #showPerMemberStats (Change)');
		});

		$(document).on('click', '.div-perMemberStats_pickRandomMember', function(event){
			if (debug) console.log('debug #showPerMemberStats Pick Random Number');
			var rndInt = getRandomInt(0, memberListToFetch.length - 1)
			memberIdSelection   = memberListToFetch[rndInt].id
			var element = document.getElementById('togglePerMemberStats');
			element.value = memberIdSelection;
			 //$('#togglePerMemberStats').val(memberIdSelection); //This is said to run slowly
			if (debugShowObject) console.log(rndInt);
			if (debugShowObject) console.log(memberIdSelection);
			$('.div-togglePerMemberStats').trigger('change');
			if (debug) console.log('finish #showPerMemberStats Pick Random Number');
		});

		if ((userId == challenge.leader.id) || (userIsAdmin)) {
			$(document).on('click', '.div-perMemberStats_awardChallenge', function(event){
				if (debug) console.log('debug #showPerMemberStats Award Challenge');
				var rowData = [[memberIdSelection, members[memberIdSelection].profile.nameNotPretty]] 
				var uuidIndex = 0
				var nameIndex = 1
				postAwardChallenge(rowData, uuidIndex, nameIndex)
			});

			$(document).on('click', '.div-perMemberStats_giftGem', function(event){
				if (debug) console.log('debug #showPerMemberStats Gift Gems');
				var rowData = [[memberIdSelection, members[memberIdSelection].profile.nameNotPretty]] 
				var uuidIndex = 0
				var nameIndex = 1
				postGiftGem(rowData, uuidIndex, nameIndex)
			});

			$(document).on('click', '.div-perMemberStats_messageUser', function(event){
				if (debug) console.log('debug #showPerMemberStats Message User');
				var rowData = [[memberIdSelection, members[memberIdSelection].profile.nameNotPretty]] 
				var uuidIndex = 0
				var nameIndex = 1
				postMessageUser(rowData, uuidIndex, nameIndex)
			});
		}
		//////////////////////////////////////////////////////////////////////
		//sectionTable Functions
		//////////////////////////////////////////////////////////////////////
		function formatTableSection(sectionId, title){
			var id    = sectionId + 'Section';
			var orderId = sectionId;
			var tableSectionId = sectionId + TABLEDISPLAYSUFFIX;
			var subTitle = sectionTables[sectionId].subTitle()
			var refreshId = sectionId + SECTIONREFRESH 
			var html = formatTableData(subTitle, refreshId, tableSectionId);
			if (! html) {
				return;
			}
			TOC[orderId] = {'target': id, 'title':  title};
			MAIN[orderId] = {'id': id, 'title': title, 'longContent': true,
				'html': html, 'refreshHtml': subTitle, 'refreshId': refreshId,
				'function': constructTable, 
				'functionPar':  [sectionId, sectionTables[sectionId].dataSet, sectionTables[sectionId].dataSetHeader, tableSectionId]};
		}
		
		
		//Function used by sections to create HTML To display table
		function formatTableData(subText, refreshId, tableId) {
			//Used by sections above if a table is required in there HTML
			var html = '';
			
			html += '<table id="' + tableId + '" class="display" width="100%"></table>'

			if (html) {
				return '<span id="' + refreshId + '">' + subText + '</span><p><div id="headerExport"></div></p>' + html ;
			}
			else {
				return '';
			}
		}

		function formatSubTableData(sectionId, criteriaKey, htmlReturnTOC) {
			var htmlTable = ''
			var htmlTableTOC = ''
			$.each(sectionsToDisplay, function(index, obj){
				if (obj.type == 'sectionTable'){
					if (obj.showOnly.length == 0 || (obj.showOnly.includes('party') && groupId == 'party') || (obj.showOnly.includes('leader') && ((userId == challenge.leader.id) || (userIsAdmin)))){
						if (sectionTables[obj.id].reproduce != undefined) {
							if (sectionTables[obj.id].reproduce.includes(sectionId)) {
								var newSectionId =  sectionId + '_' + obj.id 
								sectionTables[newSectionId] = _.cloneDeep(sectionTables[obj.id])
								sectionTables[newSectionId].dataSet = []
								sectionTables[newSectionId].reproduce = undefined
								sectionTables[newSectionId].reproduction = sectionId
								
								
								$.each(exportOptions, function(index2, obj2){ 
										$.each(sectionTables[obj.id].reproduceSel[sectionId].hide, function(index3, obj3){ 
										
										var indexToRemove = sectionTables[newSectionId][obj2.id].show.indexOf(obj3);
										if (indexToRemove > -1) {
											sectionTables[newSectionId][obj2.id].show.splice(indexToRemove, 1);
										}
									});
								});
								
								$.each(sectionTables[obj.id].dataSet, function(index2, obj2){
									if (obj2[sectionTables[obj.id].reproduceSel[sectionId].selection] == criteriaKey) sectionTables[newSectionId].dataSet.push(obj2)
								});
								htmlTableTOC += '<li><a href="#' + 'toc_' + obj.id + '_' + newSectionId  + '" target="_self">' + obj.title + '</a></li>'
								htmlTable += '<hr class="padded" />'
								htmlTable += '<h3 id="' + 'toc_' + obj.id + '_' + newSectionId +'">' + obj.title + '</h3>'
								htmlTable += '<table id="' + newSectionId + TABLEDISPLAYSUFFIX + '" class="display" width="100%"></table>'
								htmlTable += htmlReturnTOC
							}
						}
					}
				}
			});
			return [htmlTable, htmlTableTOC]
		}
	}
}	



if (debug) console.log('debug 99');	
});
</script>	


<style>

/*********************************************************************
****   Page-wide   ***************************************************
*********************************************************************/
body {
    font-family: Helvetica, Arial, sans-serif;
    font-size: 14px;
    background-color: rgb(173, 208, 215);
}



#innerBody {
    margin: 20px;
    padding: 5px 20px 30px 20px;
    background-color: rgb(242, 242, 230);
}
#loading {
    margin-right: 30px;
    margin-left: 30px;
    color: orange;
    font-size: 1.5em;
    font-weight: bold;
}
#loading ul {
    font-size: 0.8em;
}
#loading ul a {
    color: orange;
}


#posting {
    margin-right: 30px;
    margin-left: 30px;
    color: orange;
    font-size: 1.5em;
    font-weight: bold;
}
#posting ul {
    font-size: 0.8em;
}
#posting ul a {
    color: orange;
}

.narrowContent {      /* The data should be as wide as the user's window   */
    max-width: 500px; /* but some explanatory paragraphs should be narrow. */
}


hr {
    width: 95%;
}
hr.padded {
    margin-top:    1em;
    margin-bottom: 2em;
}

.show {
    display: block;
}
.hide {
    display: none;
}
.clear {
    clear: both;
}

.subheading {
    font-weight: bold;
}
.highlight {
    font-weight: bold;
}
.lowlight { /* like highlight but less so */
    font-style: italic;
}
.explanation {
    font-style: italic;
}
abbr {
    border-bottom: 1px dashed black;
}
img.emoji {
    margin-bottom: -0.25em;
}
.forCopyPaste {
    /* used to add blank lines that we want when copying text to clipboard,
       but we don't want to see extra whitespace on the screen */
    margin-top: -1em;
}
ul.padded > li {
    padding: 3px 0;
}

.neutral {
    background-color: #fffbd0; /* yellow */
}
.danger {
    background-color: #ffcccc; /* red */
    /* background-color: #F5A9A9; */ /* darker red */
}
.safe {
    background-color: #bdd8fc; /* blue */
    /* green+red and green+yellow are not good for colour-blind people */
}


/*********************************************************************
****   Page-wide Data Tables   ********************************
*********************************************************************/


a.dt-button.columnGroupButton {
	color: orange;
}

a.dt-button.awardChallengeButton {
	color: orange;
}
a.dt-button.giftGemButton {
	color: orange;
}
a.dt-button.messageUserButton {
	color: orange;
}


/*********************************************************************
****   Page-wide Show/Hide Toggling   ********************************
*********************************************************************/
.mainSectionClose,
.showHideToggle,     /* for toggling by id */
.showHideToggleClass /* for toggling by class */
{
    cursor: pointer;
    text-decoration: underline;
    color: purple;
}
.closer { /* as in "a thing that closes", not "nearer" */
    margin-top: 30px;
    padding-top: 15px;
    padding-bottom: 15px;
}
.closer:hover {
    border: 1px dashed lightgrey;
}
.developerData {
    font-family: monospace;
}


/*********************************************************************
****   Header   ******************************************************
*********************************************************************/
h1 {
    float: left;
}
h1>a:first-child { /* "Habitica" link in header */
    color: black;
    text-decoration: none;
}
h1>a:first-child:hover { /* "Habitica" link in header */
    text-decoration: underline;
}
h1 span {
    font-size: 0.5em;
}
h2 {
    margin-top: 30px;
}

#headerExtras .showHideToggle {
    white-space: nowrap;
}
#userNameDisplay {
    text-align: right;
    font-weight: bold;
    font-size: 2em;
    margin-bottom: 10px;
}
#userNameDisplay {
    text-align: right;
    font-weight: bold;
    font-size: 2em;
    margin-bottom: 10px;
}
#GemsOwned {
    font-size: 0.5em;
}

#challengeNameDisplay {
    text-align: left;
    font-weight: bold;
    font-size: 2em;
}

#explanationAndClearLinks {
    text-align: right;
}
#explanationAndClearLinks span {
    padding-left: 10px;
}


/*********************************************************************
****   Version History   *********************************************
*********************************************************************/

#versionChanges dl {
    margin-left: 30px;
}
#versionChanges dl dt {
    font-size: 1.15em;
    font-weight: bold;
}
#versionChanges dl dt .date {
    padding-left: 10px;
    font-size: 0.8em;
    font-weight: normal;
}
#versionChanges .showHideToggle {
    padding-bottom: 15px;
    margin-bottom: 10px;
}

/*********************************************************************
****   API Form and Documentation   **********************************
*********************************************************************/

#documentationAndForm > div {
    max-width: 750px;
}
#documentationAndForm #documentationAndFormClose {
    display: none;
    max-width: 100%;
}
#documentationAndForm div h2 {
    font-size: 1.3em;
}
#documentationAndForm li {
    margin-bottom: 10px;
}

#userApiDetailsForm {
    margin: 30px;
}
#userApiDetailsForm fieldset {
    max-width: 50em;
}
#userApiDetailsForm fieldset label,
#userApiDetailsForm fieldset input[type="submit"] {
    display: block;
    float: left;
    clear: left;
    margin: 10px 0;
}
#userApiDetailsForm fieldset input[type="button"] {
    display: block;
    float: left;
    clear: left;
    margin: 10px 0;
}
#userApiDetailsForm fieldset label span {
    display: block;
    float: left;
    width: 12em;
}
#userApiDetailsForm fieldset label input {
    float: left;
    width: 30em;
}
#userApiDetailsForm input[type="checkbox"] {
    width: auto;
}
#userApiDetailsForm fieldset p {
    clear: both;
}
#userApiDetailsForm legend .highlight {
    font-size: 1.3em;
}
#userApiDetailsForm fieldset li {
    margin-bottom: 7px;
}



/*********************************************************************
****   Dashboard   ***************************************************
*********************************************************************/
#DASHBOARD ul {
    float: left;
}
#DASHBOARD li {
    text-align: center;
    width: 120px;
    background-color: #fffbd0; /* yellow */
    border: 1px;
    padding: 4px;
    margin-right: 4px;
    float: left;
    list-style-type: none;
}
#DASHBOARD li.showHideToggle {
    text-decoration: none;
    color: black;
}
#DASHBOARD li > div {
    box-shadow: 1px 1px 1px 1px #666666;
}
#DASHBOARD .value {
    font-size: 2.15em;
    font-weight: bold;
    padding: 2px;
}
#DASHBOARD .label {
    font-size: 0.75em;
    padding: 1px;
}
#DASHBOARD .dropCap {
    font-size: 0.7em;
}


/*********************************************************************
****   Table Of Contents   *******************************************
*********************************************************************/
ul#tableOfContents {
    list-style-type: none;
}
ul#tableOfContents ul {
    list-style-type: none;
    margin-left: 1em;
    padding: 0;
}
ul#tableOfContents li {
    font-size: 1.1em;
    padding: 2px 0;
}
ul#tableOfContents > li {
    float: left;
    margin-right: 20px;
}


/*********************************************************************
****   Specific Sections   *******************************************
*********************************************************************/
#MAIN > * {
    display: none; /* all sections hidden by default */
}



#overviewSection table tr td {
    border: 2px solid lightgrey;
	text-align: center;
	padding: 5px;
}

table#perMemberStats_participantDetails {
	text-align: left;
}

#perMemberStats_awardChallenge.div-perMemberStats_awardChallenge {
	color: orange;
	padding: 5px;
	margin: 5px;
	margin-left: 20px
}
#perMemberStats_giftGem.div-perMemberStats_giftGem {
	color: orange;
	padding: 5px;
	margin: 5px
}
#perMemberStats_messageUser.div-perMemberStats_messageUser {
	color: orange;
	padding: 5px;
	margin: 5px
}

</style>
</head>
<body><div id="innerBody">	
<h1><a href="https://habitica.com/">Habitica</a> Challenge Data Tool
    <span class="showHideToggle" data-target="versionChanges" data-closemainsections="true">(v3.0)</span></h1><!-- VERSION TOGGLE -->
<div id="headerExtras"></div>
<hr class="clear" />
<div id="headerGroupExtras"></div>
<hr class="clear" />


<div id="loading">
    <div class="good hide">
        <p>Please wait. Fetching data from
        <span id="serverName">Habitica</span>... <span id="statusFetch"></span></p>
    </div>
    <div class="bad hide">
        <p>There was an error obtaining your data.</p>
        <ul class="padded">
			<li>Check your challenge id is a Challenge Id which is a string of characters similar to your UID. The Challenge ID appears at the end of the URL. Eg. 2ff9822b-27f2-4774-98da-db349b57a38e</li>
            <li>Please reload the page and then check that your <a href="https://habitica.com/user/settings/api">User ID and API Token</a> are correct.</li>
            <li>If you're using Internet Explorer, try another browser. <a href="https://www.google.com/intl/en/chrome/browser/">Chrome</a> or <a href="https://www.mozilla.org/en-US/firefox/new/">Firefox</a> will be more reliable.</li>
            <li>If the page's URL starts with "http://" change it to start with "https://" (or just use <a href="https://oldgods.net/habitica/cTheDragons/challenge.html">this correct link</a>).</li>
            <li>If neither of those help, contact me! See <strong>"Help and Contact Details"</strong> at the bottom of this page.</li>
        </ul>
    </div>
</div>
<div id="posting">
	<div class="good hide">
		<p>Please wait. Posting data to
		<span id="serverName">Habitica</span>... <span id="statusPost"></span></p>
	</div>
</div>

<div id="versionChanges" class="hide"><!-- VERSION SECTION -->
    <h2>Version History</h2>
    <dl>
		<dt>3.0 - Roses & Clunky Lines<span class="date">2019-05-01</span></dt>
        <dd><ul>
 			<li>Features:
                <ul>
					<li>Adding usernames (with alt if username not defined).</li>
					<li>Able to put carriage returns into message (Clunky but will do for now).</li>
					<li>Adding more detail about the Leader in text sections</li>
					<li>Made usernames and display names linked to Habitica Profile Page.</li>
				</ul> 
            </li>
			<li>Documentation:
                <ul>
					<li>Updated reference & email for spam to generic Admin.</li>
					<li>Ensure display name and username displayed in non grid data.</li>
					<li>Username only on Baby grid data.</li>
                </ul>
            </li>
			<li>Bug Fixes:
                <ul>
					<li>Able to display data if "no owner".</li>
					<li>Handling in habits no scoredUp or scoredDown data.</li>
               </ul>
            </li>				
		</ul></dd>
		<dt>2.2 - Bad Daily Habit<span class="date">2018-06-25</span></dt>
        <dd><ul>
			<li>Bug Fixes:
                <ul>
					<li>Fixing negative click count for missed dailies in All Task History.</li>
               </ul>
            </li>	
		</ul></dd>	
		<dt>2.1 - No More Time for Habits<span class="date">2018-06-25</span></dt>
        <dd><ul>
	        <li>Features:
                <ul>
					<li>Modifying code to handle new habit recording structure. Clicks summarised per day.</li>
				</ul> 
			<li>Documentation:
                <ul>
					<li>Updating notes to match new habit structure and how dailies history are recorded (now actual date time of when daily was ticked, not cron time).</li>
                </ul>
			<li>Bug Fixes:
                <ul>
					<li>Removing the duplicate for completed in dailies.</li>
               </ul>
            </li>	
		</ul></dd>	
		<dt>2.0 - Bag full of Goodies<span class="date">2018-04-30</span></dt>
        <dd><ul>
	        <li>Features:
                <ul>
					<li>Added the ability to handle timeouts when fetching members and list of members.</li>
					<li>Hide Avatar images now on as default to avoid memory issues.</li>
					<li>Added other url parameters, bear and porridge.</li>
					<li>Added json of appearance to chat.</li>				
				</ul> 
			<li>Documentation:
                <ul>
					<li>Fix thanks for Blade. (Link to code supplied).</li>
                </ul>
			<li>Bug Fixes:
                <ul>
					<li>Url parameters apply independent of whether or not the user id parameter is supplied. (Thank you @Accio Books!)</li>
					<li>Checkbox url parameters can be set to false.</li>
					<li>Put back Participants likes.</li>
               </ul>
            </li>	
		</ul></dd>	
		<dt>1.8 - Message the Owner<span class="date">2017-12-10</span></dt>
        <dd><ul>
	        <li>Features:
                <ul>
					<li>Added Feature to Message the owner directly from the Challenge Tool.</li>
					<li>Showed User Ids for Owners and Guild Leaders in the Overview.</li>
				</ul>
            </li>		
		</ul></dd>	
		<dt>1.7 - Pretty Pictures<span class="date">2017-11-10</span></dt>
        <dd><ul>
	        <li>Features:
                <ul>
					<li>Added Avatar Image. Deprecating Avatar link (Not currently available).</li>
					<li>Added ability to hide Avatar Image for Faster Loading</li>
					<li>Added Summary and Category information for Challenge.</li>
					<li>Added ary and Category information for Guild</li>
					<li>Remove deprecated Leader Message.</li>
					<li>Updating URL to new website format.</li>
					<li>Better error with POST functions handling.</li>
					<li>Direct links to challenge at Habitica</li>
					<li>Added hide_avatar as url option.</li>
				</ul> 
            </li>
	        <li>Documentation:
                <ul>
					<li>Clean up of code.</li>
					<li>Minor fixes to formatting of check boxes.</li>
                </ul>
            </li>		
		</ul></dd>	
		<dt>1.6 - More Lessons in Counting<span class="date">2017-09-11</span></dt>
        <dd><ul>		
            <li>Features:
                <ul>
					<li>Set the Guild Chat to the Duelling Grounds Tally for the Duelling Grounds as this used more by challenges.</li>
				</ul> 
            </li>
	        <li>Bug Fixes:
                <ul>
					<li>Single direction habits now count correctly in the right direction.</li>
               </ul>
            </li>
		</ul></dd>
		<dt>1.5 - Really I Can Count!<span class="date">2017-08-19</span></dt>
        <dd><ul>		
	        <li>Bug Fixes:
                <ul>
					<li>Better handling of null strings with markdown.</li>
					<li>Mage totals now show in overview.</li>
               </ul>
            </li>
		</ul></dd>	
		<dt>1.4 - Links!<span class="date">2017-08-02</span></dt>
        <dd><ul>
            <li>Features:
                <ul>
					<li>Adding Link to Party Tool for Guild</li>
					<li>Adding id for Challenge in Header</li>
				</ul> 
            </li>
	        <li>Documentation:
                <ul>
					<li>Minor wording changes for the section descriptions.</li>
                </ul>
            </li>		
	        <li>Bug Fixes:
                <ul>
					<li>Handle no owner when retrieving challenges list. (Left it to error when choosing a challenge when there is no owner - force users to get the data fixed).</li>
					<li>documentation / options always shows next to the re-fetch button</li>
					<li>Typo Successfully</li>
               </ul>
            </li>
		</ul></dd>	
		<dt>1.3 - Banish the Chatter Bug<span class="date">2017-07-04</span></dt>
        <dd><ul>
            <li>Features:
                <ul>
					<li>Added last cron to Participant details in Per Participant Stats/Random Winner.</li>
				</ul> 
            </li>
	        <li>Documentation:
                <ul>
					<li>Modified Participant details in Per Participant Stats/Random Winner to table for easier reading.</li>
                </ul>
            </li>		
	        <li>Bug Fixes:
                <ul>
                    <li>Zero Chat Guilds are now fetch. Thanks @Altariel!</li>
					<li>Chat Export and Chat Likes now show correctly for per member/random winner stats.</li>
					<li>Papa Bear Option of Task Challenges now show all and correctly named columns for Tasks Overall.</li>
               </ul>
            </li>
		</ul></dd>	
		<dt>1.2 - Message Ids<span class="date">2017-06-26</span></dt>
        <dd><ul>
            <li>Features:
                <ul>
					<li>Added Message Id to Chat Sections for easy searching.</li>
				</ul> 
            </li>
		</ul></dd>	
		<dt>1.1 - Tick! Fixed up the Place<span class="date">2017-06-26</span></dt>
        <dd><ul>
            <li>Features:
                <ul>
					<li>Added CheckList details in Participant Overall and Participant per Task.</li>
					<li>Pressing the "Enter" key on the login screen down detects if you filled out challenge information. (Smart Detect if no challenge information will get list otherwise gets challenge data).</li>
				</ul> 
            </li>
	        <li>Documentation:
                <ul>
					<li>Formatting the front login page. Minor layout change of labels. Removing the word BETA. (Oops forgot to take the construction sign down).</li>
					<li>Slight modification to the message warning to make it clearer (Added extra punctuation).</li>
                </ul>
            </li>		
	        <li>Bug Fixes:
                <ul>
                    <li>Overview: now reflects it is the Overview for the challenge! Thanks @Altariel! </li>
               </ul>
            </li>
		</ul></dd>	
		<dt>1.0 - Public Release!<span class="date">2017-06-19</span></dt>
        <dd><ul>
            <li>Features:
                <ul>
					<li>Allowed user to have a select list of challenges they owned.</li>
				</ul> 
            </li>
	        <li>Documentation:
                <ul>
					<li>Further changing Member Details => Participant in Sections where it was missed</li>
					<li>Add gems sent in confirmation message.</li>
                </ul>
            </li>		
	        <li>Bug Fixes:
                <ul>
                    <li>Per Member stats only show leadership buttons if a leader.</li>
					<li>Does not show HTML information if using leadership buttons in Participant List.</li>
               </ul>
            </li>
		</ul></dd>	
		<dt>0.9 - beta release - While the Olds Gods Slept<span class="date">2017-06-03</span></dt>
        <dd><ul>
            <li>Features:
                <ul>
					<li class="subheading">Tasks Overall</li>
					<li>Added Positive Clicks and Negative Clicks to Dashboard</li>
					<li>Displaying correct error messages from Habitica. No more hardcoding.</li>
					<li>Added Challenge Activity Breakdown to Overview.</li>
					<li>Added Task (Type) Breakdown to Overview.</li>
					<li>Added UID and if In Inn on Per Participant Stats.</li>
					<li>Modify default columns for Baby & Mama View for Participant Overall.</li>
					<li>Modify default columns for Baby View for Participant per Task.</li>
				</ul> 
            </li>
	        <li>Documentation:
                <ul>
                    <li>Rename Section Member Overall  Completion = > Participant Overall</li>
					<li>Rename Section Member per Task Completion = > Participant per Task</li>
					<li>Rename Section Member List = > Participant List</li>
					<li>Rename Section Member Activity = > Participant Activity</li>
					<li>Rename Section Per Member Stats/Random Winner = > Per Participant Stats/Random Winner</li>
					<li>Rename Section All Task Completion History = > All Task History </li>
					<li>In Overview Section Member => Participant</li>
					<li>Minor Help text with Completion Stats tables</li>
					<li>All Sections Completed => Clicks/Clicked</li>
                </ul>
            </li>		
	        <li>Bug Fixes:
                <ul>
                    <li>Fixed Streaks to report correctly (A Negative streak is a negative Streak)</li>
					<li>Fixed to-dos always to be counted as positive click regardless of value.</li>
					<li>Handle zero habit difference values. Treated as positive. (Though this may be a bug in Habitica).</li>
					<li>Awarding Gems in Per Member Stats/Random Winner now works all the time. Required to create new buttons for single section to fix. (Thank you @mandiferous. I finally found your bug)</li>
					<li>Typo Challenge</li>
               </ul>
            </li>
		</ul></dd>	
		<dt>0.8 - beta release - Are We There Yet? <span class="date">2017-05-29</span></dt>
        <dd><ul>
            <li>Features:
                <ul>
					<li>Names now render with markdown based on porridge option.</li>
					<li>Prize at the top links to Select Winner. (Thank you @Accio Books!)</li>
				</ul> 
            </li>
	        <li>Documentation:
                <ul>
                    <li>Minor text change re member activity.</li>
					<li>Update to chat and PM Descriptions. (Thank you @Lorem)</li>
                </ul>
            </li>		
	        <li>Bug Fixes:
                <ul>
                    <li>Allowed to Party challenges to be viewed. (Zero missing data for buffs/Transformation activity even though not calculated) (Thank you @Lalaitha)</li>
					<li>Pretty names for tasks</li>
					<li>Pretty names for challenges</li>
					<li>Gem gifting message now shows message sent. (Thank you @mandiferous)</li>
					<li>Removed incorrect references to the Data Display Tool. (Thank you @Alys)</li>
					<li>Cold porridge now shows carriage returns.</li>
					<li>Typo Participants</li>
					<li>Minor formatting issues in Overview.</li>
               </ul>
            </li>
		</ul></dd>	
		<dt>0.7 - beta release - Kill the Bug! <span class="date">2017-05-13</span></dt>
        <dd><ul>
	        <li>Bug Fixes:
                <ul>
                    <li>Re-fetching won't loose your random member</li>
					<li>Re-fetching won't cause member selection/random member to loop multiple times</li>
					<li>Leadership tools display correctly when switching challenges</li>
					<li>Fix issue for Mod accessing Admin Tools</li>
               </ul>
            </li>
		</ul></dd>
		<dt>0.6 - beta release - Let the Mods Play! <span class="date">2017-05-13</span></dt>
        <dd><ul>
            <li>Features:
                <ul>
					<li>Allow the Mods to use the Admin Tools</li>
				</ul> 
            </li>
	        <li>Bug Fixes:
                <ul>
                    <li>Fixed some version history gone astray</li>
					<li>Won't crash if fetch details change without reloading - Need to fix leadership buttons appearing though</li>
               </ul>
            </li>
		</ul></dd>
		<dt>0.5 - beta release - The Final Push <span class="date">2017-05-13</span></dt>
        <dd><ul>
            <li>Features:
                <ul>
					<li>Added Challenge Gem Amount</li>
					<li>Added User Gem Amount</li>
				</ul> 
            </li>
	        <li>Documentation:
                <ul>
                    <li>Added notes about dates are displayed locally.</li>
					<li>Added notes about leadership buttons.</li>
					<li>Added notes on how to select multiple rows if leadership buttons available.</li>
					<li>Ensured all columns are right justified for numbers and dates.</li>
					<li>Minor Typos! I'm not *positive* I have them all ;)</li>
                </ul>
            </li>		
	        <li>Bug Fixes:
                <ul>
                    <li>Leadership buttons now show if your the leader of the challenge. Not the leader of the guild. (Oops!)</li>
					<li>Rename the confusing button from Fetch Group Data to Fetch Challenge Data (Only now this is noticed! Thanks @Alys)</li>
               </ul>
            </li>
		</ul></dd>
 		<dt>0.4 - beta release - LIKE the rearrange? <span class="date">2017-05-09</span></dt>
        <dd><ul>
            <li>Features:
                <ul>
					<li class="subheading">Chat Likes</li>
					<li class="subheading">PMs</li>
					<li class="subheading">Per Member Stats/Random Winner</li>
					<li>Add Likes and Participant Likes Counts to Chat Export</li>
					<li>Added Message, Gift Gems and Award Challenge to all tables if challenge owner. (Created function as required).</li>
					<li>Remove Leadership Tools, Member Stats, Member Attribute (Function replace and/or information not useful).</li>
				</ul> 
            </li>
	        <li>Documentation:
                <ul>
                    <li>Rearrange Menu headers and sections</li>
               </ul>
            </li>		
		</ul></dd>
		<dt>0.3 - beta release - Quick Fixes to avoid being a Fool! <span class="date">2017-04-01</span></dt>
        <dd><ul>
            <li>Features:
                <ul>
					<li>Added Created date of Challenge to the header</li>
				</ul> 
            </li>
	        <li>Documentation:
                <ul>
                    <li>Rename Admin to Mod (Less confusion)</li>
					<li>Rename Leader to Owner</li>
                </ul>
            </li>		
	        <li>Bug Fixes:
                <ul>
                    <li>Make Task information left justified</li>
					<li>Fix task totals do not keep increasing when changing porridge options</li>
					<li>Do not count dailies that are not due in streaks.</li>
                </ul>
            </li>
		</ul></dd>
        <dt>0.2 - beta release - This one is Useful! <span class="date">2017-03-30</span></dt>
        <dd><ul>
            <li>Features:
                <ul>
					<li>Upgrading code as per changes to Party And Guild Data Tool</li>
					<li class="subheading">Random Winner (Placeholder)</li>
					<li class="subheading">Leadership Tools</li>
					<li class="subheading">Chat Export with System Messages</li>
					<li class="subheading">Member Overall Completion</li>
					<li class="subheading">Member per Task Completion</li>
					<li class="subheading">All Task Completion History</li>
				</ul> 
            </li>
	        <li>Documentation:
                <ul>
                    <li>Possible Future Features updated</li>
                    <li>Help and Contact Details updated</li>
                </ul>
            </li>		
		</ul></dd>
		<dt>0.1 - beta release <span class="date">2016-12-12</span></dt>
        <dd><ul>
            <li>Features:
                <ul>
					<li class="subheading">Overview</li>
                    <li class="subheading">Member List Section (sample)</li>
					<li class="subheading">Member Activity Section (sample)</li>
					<li class="subheading">Member Stats Section (sample)</li>
                    <li class="subheading">Chat Export Section</li>
					<li class="subheading">Chat Export without System Messages Section</li>
                </ul>
            </li>
            <li>Documentation:
                <ul>
                    <li>Privacy and security notes (also related comments within the code)</li>
                    <li>What's On This Page? (descriptions of each feature)</li>
                    <li>Possible Future Features</li>
                    <li>Suspected Bugs (no support for old browsers; mobile support unknown)</li>
                    <li>Help and Contact Details</li>
                </ul>
            </li>
        </ul></dd>
    </dl>
    <div class="showHideToggle closer" data-target="versionChanges" data-scrolltotop="true">close version history <span class="lowlight">(or click the version number again to close)</span></div>
    <hr />
</div><!-- end of div id="versionChanges" -->


<div id="DASHBOARD"></div>
<div id="TOC"></div>
<div id="MAIN"></div>

<div id="documentationAndForm">
   <p>This page shows you certain information from your <a
   href="https://habitica.com/">Habitica</a> account. You can read the
   full list below, or just enter your details and try it out.</p>

    <iframe src="js/null.htm" id="formPasswdSaveFix" name="formPasswdSaveFix" style="display:none"></iframe><!-- DAMN YOU CHROME!! DAMN YOU!!!! http://stackoverflow.com/a/9116737 -->
    <form id="userApiDetailsForm" method="POST" action="" target="formPasswdSaveFix">
        <fieldset>
            <legend><span class="highlight">Enter your Habitica API details</span>
            (from the <a href="https://habitica.com/user/settings/api">Settings
             -&gt; API page</a>)
            </legend>
            <label for="userId"><span>User ID</span>
                <input type="text" name="userId" id="userId"/>
            </label>
            <label for="apiToken"><span>API Token</span>
                <input type="password" name="apiToken" id="apiToken"/>
            </label>
			<div id="challengeSelector"></div>
			<label for="hideAvatar"><span>Hide Avatar Images? (for faster load)</span>
                <input type="checkbox" name="hideAvatar" id="hideAvatar" checked/>
            </label>
			<div id="exportOptionSelector"></div>
            <input class="div-fetchData" type="submit" value="Fetch Challenge Data" />
			<p class="highlight">Challenge ID:</p>
			<p>Enter either the Challenge ID, or the URL for the Challenge. The Challenge ID is a string of characters similar to your User ID, e.g. 2ff9822b-27f2-4774-98da-db349b57a38e. The Challenge ID appears at the end of the URL or on the left hand panel on the website. It is not the name of the challenge. You can always just post the entire URL, which is much easier!</p>
			<div id="exportOptionDesc"></div>
            <p class="highlight">Privacy and security notes:</p>
            <ul>
            <!--<li>If you access this page from the Data menu on the Habitica
            website, your User ID will be automatically added to the form
            above.</li> $$$ Maybe one day when the tool that good--->
            <li>Your API Token is a password - do not share it with anyone,
            not even the maintainer of this page if you are seeking help.</li>
            <li>When you enter your User ID and API Token here and click
            "Fetch My Data", your ID and Token are sent to Habitica's servers.
            They are not sent anywhere else.
            To confirm that, you can ask someone who knows the JavaScript
            programming language to examine the source of this page.</li>
            <li>This page does not save your User ID and API Token to any
            location, but your browser might, if it has been configured to
            save form and password information. If you are using this page
            on a shared computer, you should clear any data that the browser
            has saved.</li>
            <li>You cannot view anyone else's private data by using this page.</li>
            <li>To clear your data, reload the page.</li>
            </ul>
        </fieldset>
    </form>


    <div>
		<h2>What's On This Page?</h2>
		<ul>
			<div id="sectionDesc"></div>
		</ul>
		<p><span class="subheading">Leadership Buttons:</span> to message challenge participants, gift gems and award & close the challenge only appear if you are the challenge owner.</p>
		<p>All dates are displayed as per users' device.</p>
		<p><span class="subheading">FYI:</span> Last Active date is the latest date of either Challenge Task Completion, Cron, Chat or Drop. It does not include if the user is chatting or using other areas of Habitica.</p>

		<h2>Possible Future Features</h2>
		<ul>
			<li>Section to choose winners by Daily/All Task Completed/Most Positive Ticks etc</li>
			<li>Column Filtering (as opposed to single search box)</li>
			<li>Multi line text box for PMs and chat messages.</li>
			<li><span class="subheading">Other Stuff?</span>: Send me ideas! Contact details are below.</li>
		</ul>

		<h2>Known Bugs</h2>
		<p>The hiding and closing of sections is a bit funky. (One day I will fix it but not today.)</p>

		<p>Internet Explorer will produce odd results if you use the "Re-Fetch Data" button. Reloading the page will fix the problem. Avoid using that button. Avoiding Internet Explorer will also work.</p>
		<p>This page will not work correctly on old browsers because it uses modern website features and relies on compliance to standards (both can be lacking in old browsers). <a href="http://browsehappy.com/">Updating your browser is important for general safety on the internet!</a> If you have upgraded your browser to the latest version and are still having problems, please tell me! Contact details are below.</p>
		<p>Regardless of what bugs there might be, this page cannot damage your account. It does not contain any code that could result in any changes being made on Habitica except actions performed through this website/API..</p>

		<h2>Thank You!</h2>
		<p>Thank you to @Alys & Ryan for their code which this is based. Thank you to Blade who provided me the code for the <a href="https://github.com/crookedneighbor/habitica-avatar">Avatars<a> both the js and implementation here. Thank you all in the <a href="https://habitica.com/groups/guild/349a36c3-66f3-4bf8-91b6-475056d9b6bb">Javascript</a> and <a href="https://habitica.com/groups/guild/2ff9822b-27f2-4774-98da-db349b57a38e">Aspiring Comrades</a> in answering my newbie questions. <p> 

		<h2>Help and Contact Details</h2>
		<p>This page has been created by <a href="http://habitica.wikia.com/wiki/User:CTheDragons">cTheDragons</a>. If you have questions, problems, or suggestions, you're welcome to contact me, although I cannot guarantee that I'll always be able to spend a lot of time on this. You can contact me at <a href="https://habitica.com/groups/guild/d9a0ec1e-352b-4697-a5d5-fb45c98fb4a3">Testing & Bug Squashing for Dragon Tools</a>. I tend to ignore emails & PMs.</p>
		<p>Code can be source at  <a href="https://github.com/cTheDragons/Habitica-Challenge-Data-Tool">Github<a>. Contributions are welcome. As already stated, any issues please report to  <a href="https://habitica.com/groups/guild/d9a0ec1e-352b-4697-a5d5-fb45c98fb4a3">Testing & Bug Squashing for Dragon Tools</a> for a faster response and to avoid duplication. </p>
		<p>If you have general questions about Habitica, post them to <a href="https://habitica.com/groups/tavern">Tavern</a> or <a href="https://habitica.com/groups/guild/5481ccf3-5d2d-48a9-a871-70a7380cee5a">Habitica Help: Ask a Question Guild</a>.</p>
    </div>
	
	<div id="documentationAndFormClose" class="showHideToggle closer" data-target="documentationAndForm" data-resettoggletext="documentationAndFormToggle">hide documentation / options</div>
	
</div><!-- end of div id="documentationAndForm" -->
	
</div><!-- end of div id="innerBody" -->
</body>
</html>